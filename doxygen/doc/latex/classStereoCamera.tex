\section{Stereo\+Camera Class Reference}
\label{classStereoCamera}\index{Stereo\+Camera@{Stereo\+Camera}}


The base class defining stereo camera.  




{\ttfamily \#include $<$stereo\+Camera.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStereoCamera_a11256fe5a509436abc714a594b6cc801}{Stereo\+Camera} (bool rectify=true)
\begin{DoxyCompactList}\small\item\em Default Constructor. \end{DoxyCompactList}\item 
\hyperlink{classStereoCamera_a0c2cd4c7b5a0cdb96370c29a42601f40}{Stereo\+Camera} (yarp\+::os\+::\+Resource\+Finder \&rf, bool rectify=true)
\begin{DoxyCompactList}\small\item\em Costructor for initialization from file. \end{DoxyCompactList}\item 
\hyperlink{classStereoCamera_a5bfcf3ef7c9d45802bacbf040e7ca112}{Stereo\+Camera} (\hyperlink{classCamera}{Camera} First, \hyperlink{classCamera}{Camera} Second, bool rectify=true)
\begin{DoxyCompactList}\small\item\em Constructor for initialization using two calibrated cameras. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a067e1e94a48cb390491fea0f6748dda8}{init\+E\+L\+AS} (yarp\+::os\+::\+Resource\+Finder \&rf)
\begin{DoxyCompactList}\small\item\em Initialization of E\+L\+AS parameters. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a398f45eeefe7979a834659cfbb7a6961}{stereo\+Calibration} (vector$<$ string $>$ image\+List, int board\+Width, int board\+Height, float sqsize=1.\+0)
\begin{DoxyCompactList}\small\item\em It performs the stereo camera calibration. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a9f06cd4b170ad0ba45b681ee93d64851}{save\+Calibration} (string extrinsic\+File\+Path, string intrinsic\+File\+Path)
\begin{DoxyCompactList}\small\item\em It saves the calibration. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_adc36a2585c583219bddbb1c7fb0725df}{set\+Images} (const Mat \&first\+Img, const Mat \&second\+Img)
\begin{DoxyCompactList}\small\item\em It stores in memory a couple of images. \end{DoxyCompactList}\item 
cv\+::\+Mat \hyperlink{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}{find\+Match} (bool visualize=false, double displacement=20.\+0, double radius=200.\+0)
\begin{DoxyCompactList}\small\item\em It finds matches between two images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity} (bool best=true, int uniqueness\+Ratio=15, int speckle\+Window\+Size=50, int speckle\+Range=16, int number\+Of\+Disparities=64, int S\+A\+D\+Window\+Size=7, int min\+Disparity=0, int pre\+Filter\+Cap=63, int disp12\+Max\+Diff=0)
\begin{DoxyCompactList}\small\item\em It computes the Disparity Map (see stereo\+Disparity). \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a2751f357e5fabc7099303d45425208d7}{undistort\+Images} ()
\begin{DoxyCompactList}\small\item\em It undistorts the images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_adf155975709fdbf09d3133899d074a02}{horn} (Mat \&K1, Mat \&K2, vector$<$ Point2f $>$ \&Points1, vector$<$ Point2f $>$ \&Points2, Mat \&Rot, Mat \&Tras)
\begin{DoxyCompactList}\small\item\em It performs the horn relative orientations algorithm i.\+e. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a36dae897d07544e8faca8c90216173a6}{horn\+Relative\+Orientations} ()
\begin{DoxyCompactList}\small\item\em It performs the horn relative orientations, all the parameters are assumed initialized in the \hyperlink{classStereoCamera}{Stereo\+Camera} object. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a3c8ef84424fa111c63437a3db8f04333}{triangulation} (Point2f \&point1, Point2f \&point2)
\begin{DoxyCompactList}\small\item\em It performs the triangulation using the stored in the internal P1 and P2 3x4 \hyperlink{classCamera}{Camera} Matrices. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_ab68c8d3bd07f542243d681fbe8c8c6b7}{triangulation} (Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)
\begin{DoxyCompactList}\small\item\em It performs the triangulation (HZ Chap 12.\+2 homogenous solution). \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_aaef25d8723eefdbab6e27c348492126b}{triangulation\+LS} (Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)
\begin{DoxyCompactList}\small\item\em It performs the least square triangulation (HZ Chap 12.\+2 Inhomogenous solution). \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a2fcd3e1767bcf04716b0e2ac76098430}{metric\+Triangulation} (Point2f \&point1, double th\+Meters=10)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a3cf53fac6336eea107a26bd5cdbbdd03}{metric\+Triangulation} (Point2f \&point1, Mat \&H, double th\+Meters=10)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a761ea623c4cde38b4fa1d798ef09b7ae}{triangulate\+Known\+Disparity} (float u, float v, float d, Mat \&H)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image and the disparity between the two R\+E\+C\+T\+I\+F\+I\+ED images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ab2eded08bca185ac22cd6343cb4c85c8}{estimate\+Essential} ()
\begin{DoxyCompactList}\small\item\em It estimates the essential matrix (3x3) E between two views. \end{DoxyCompactList}\item 
bool \hyperlink{classStereoCamera_a180388e93b654802c7c56c18d206214b}{essential\+Decomposition} ()
\begin{DoxyCompactList}\small\item\em It decomposes the essential matrix in Rotation and Translation between the two views. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_aefb25fc2ecd8d0ce484e5981769dd635}{chierality} (Mat \&R1, Mat \&R2, Mat \&t1, Mat \&t2, Mat \&R, Mat \&t, vector$<$ Point2f $>$ points1, vector$<$ Point2f $>$ points2)
\begin{DoxyCompactList}\small\item\em It performs the chierality test\+: given a couple of rotation matrices, translation vectors and matches it finds the correct rotation and translation s.\+t. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ac0cb76a6994bd7ab915cb02d83cf8f8e}{get\+Im\+Left} () const
\begin{DoxyCompactList}\small\item\em It returns the left (first) image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ac7930aa4fa0681246e74c08cf4b1079b}{get\+Im\+Right} () const
\begin{DoxyCompactList}\small\item\em It returns the right (second) image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a52ba4f0331f3690ca0f983b10bd0c783}{get\+Im\+Left\+Und} () const
\begin{DoxyCompactList}\small\item\em It returns the left undistorted image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a19009c20003a5c7e957a4b3c34913fe9}{get\+Im\+Right\+Und} () const
\begin{DoxyCompactList}\small\item\em It returns the right undistorted image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a74adec3c305b13df4757e105cd72a7db}{get\+Disparity} () const
\begin{DoxyCompactList}\small\item\em It returns the disparity image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a4a6e408446750224499ed9ecdc51629e}{get\+Disparity16} () const
\begin{DoxyCompactList}\small\item\em It returns the disparity image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a9f10e66261a0211e5d786abc3df8a70b}{getQ} () const
\begin{DoxyCompactList}\small\item\em It returns the 4x4 disparity-\/to-\/depth mapping matrix. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a932e0ebd63c3e9a93b33c1846459aadc}{get\+Kleft} () const
\begin{DoxyCompactList}\small\item\em It returns the 3x3 left camera matrix. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a6f9e53e949b77cd19e28a4ec92034a3d}{get\+Kright} () const
\begin{DoxyCompactList}\small\item\em It returns the 3x3 right camera matrix. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ab02e0869a054fe23d2b56def81a1a947}{get\+Fundamental} () const
\begin{DoxyCompactList}\small\item\em It returns the 3x3 fundamental matrix. \end{DoxyCompactList}\item 
const vector$<$ Point2f $>$ \& \hyperlink{classStereoCamera_aa50cb648f92d099e1ffbb7bab57c3fc3}{get\+Match\+Left} () const
\begin{DoxyCompactList}\small\item\em It returns the pixel coordinates of the matches in the left image. \end{DoxyCompactList}\item 
const vector$<$ Point2f $>$ \& \hyperlink{classStereoCamera_ac8b01bc577cc3de8e7e8bc246d5c50f0}{get\+Match\+Right} () const
\begin{DoxyCompactList}\small\item\em It returns the pixel coordinates of the matches in the right image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a3ca6d46fc45835bff5fa0a5753ca40c0}{get\+Translation} () const
\begin{DoxyCompactList}\small\item\em It returns the translation vector between the two cameras. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a08b520f9976fc3213047844fedc02a54}{get\+Rotation} () const
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the two cameras. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ae1c7ef2cc1a3de5d10c6bb39fbb78719}{get\+MapperL} () const
\begin{DoxyCompactList}\small\item\em It returns the mapping between the original left camera and the rectified left camera. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ac3f7763fdb6ed57f96924bb0b32b4ea7}{get\+MapperR} () const
\begin{DoxyCompactList}\small\item\em It returns the mapping between the original right camera and the rectified right camera. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ab3adb747963c617fd2fe1a919b0c59c7}{get\+R\+Lrect} () const
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the original left camera and the rectified left camera. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a44e111911af89a299b134fd91b4bc7d6}{get\+R\+Rrect} () const
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the original right camera and the rectified right camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a1329b3894d527e1505618f57a1304624}{set\+Rotation} (Mat \&Rot, int mode=0)
\begin{DoxyCompactList}\small\item\em It sets the rotation matrix (if known) between the first and the second camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a7b10f1218e8e70f47b22080ba1820d39}{set\+Translation} (Mat \&Tras, int mul=0)
\begin{DoxyCompactList}\small\item\em It sets the translation vector (if known) between the first and the second camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a54754623497c8dddb61f520e17f465f8}{set\+Intrinsics} (Mat \&K1, Mat \&K2, Mat \&Dist1, Mat \&Dist2)
\begin{DoxyCompactList}\small\item\em It sets the intrinsic parameters. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ae5ac866c6d4b6c4819b01a918e7b61e0}{rectify\+Images} ()
\begin{DoxyCompactList}\small\item\em The method rectifies the two images\+: it transform each image plane such that pairs conjugate epipolar lines become collinear and parallel to one of the image axes (i.\+e. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_ad81c9f7f4f15ef3f1e61d34fd8df9856}{get\+L\+Rectified} () const
\begin{DoxyCompactList}\small\item\em The method returns the first rectified image. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_aff19b07a766c01d04ed623a05ef4d67d}{get\+R\+Rectified} () const
\begin{DoxyCompactList}\small\item\em The method returns the second rectified image. \end{DoxyCompactList}\item 
vector$<$ Point2f $>$ \hyperlink{classStereoCamera_a03406c9d31c1b765a8d6ef9641222309}{project\+Points3D} (string camera, vector$<$ Point3f $>$ \&points3D, Mat \&H)
\begin{DoxyCompactList}\small\item\em The method returns the 2D projection of a set of 3D points in the cartesian space to the specified camera. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a52ef2f3401488e5c4fa6badd1336f96d}{compute\+World\+Image} (Mat \&H)
\begin{DoxyCompactList}\small\item\em The method returns a 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_a589ca8eb4ebfc4377589a77bb15b85b7}{get\+Dist\+Coeff\+Right} () const
\begin{DoxyCompactList}\small\item\em It returns the 5x1 right distortion coefficients. \end{DoxyCompactList}\item 
const Mat \& \hyperlink{classStereoCamera_af9e52f941837f0db26d150d0ca4ff3bc}{get\+Dist\+Coeff\+Left} () const
\begin{DoxyCompactList}\small\item\em It returns the 5x1 left distortion coefficients. \end{DoxyCompactList}\item 
Point2f \hyperlink{classStereoCamera_af64550bb8a7a665930dee5eea87b7e47}{get\+Distorted\+Pixel} (int u, int v, int cam=1)
\begin{DoxyCompactList}\small\item\em Given the u,v pixel coordinates in the undistorted image the method returns the original position of the pixel in the distorted frame. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a6580ff03c7cec5c385ec717f9c018e21}{draw\+Matches} ()
\begin{DoxyCompactList}\small\item\em The method returns a 3-\/\+Channels 8bit image with the image matches. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ae683fafa11ea73e4b4c278402be259b6}{set\+Matches} (std\+::vector$<$ cv\+::\+Point2f $>$ \&pointsL, std\+::vector$<$ cv\+::\+Point2f $>$ \&pointsR)
\begin{DoxyCompactList}\small\item\em The function initialize the matches of the current image pair. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a9ecb303d7b36eaf5f086d8ddebd29b95}{set\+Expected\+Position} (Mat \&Rot, Mat \&Tran)
\begin{DoxyCompactList}\small\item\em The function set the expected Rotation and Translation parameters for the current image pair. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a3fe4e87322f8644cd21ce06e8522c815}{FfromP} (Mat \&P1, Mat \&P2)
\begin{DoxyCompactList}\small\item\em The function computes the fundamental matrix starting from known camera matrices. \end{DoxyCompactList}\item 
Point2f \hyperlink{classStereoCamera_a3d8fde0cbd4604085b883f22cc606c01}{from\+Rectified\+To\+Original} (int u, int v, int camera)
\begin{DoxyCompactList}\small\item\em Given the u,v pixel coordinates in the rectified image the method returns the position of the pixel in the non-\/rectified frame. \end{DoxyCompactList}\item 
cv\+::\+Mat \hyperlink{classStereoCamera_ac92ce0b90b69773284be5825b0199bda}{remap\+Disparity} (cv\+::\+Mat disp)
\begin{DoxyCompactList}\small\item\em Remaps the disparity map on the basis of the mapping previously computed. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a5b15c07def1c09f53bfc6141f303fa09}{update\+Mappings} ()
\begin{DoxyCompactList}\small\item\em X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+XX. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{classStereoCamera_ab7a8b46716078f726d757c96e1f34cc6}} 
Mat {\bfseries filtered\+\_\+disp}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The base class defining stereo camera. 

It allows to calibrate the cameras, to undistort a pair of images, to find matches between two images, to triangulate points and to estimate motion between two images. The basic assumption is that the two images come from a stereo camera, however this class works also with two arbitrary images. 

Definition at line 91 of file stereo\+Camera.\+h.



\subsection{Constructor \& Destructor Documentation}
\mbox{\label{classStereoCamera_a11256fe5a509436abc714a594b6cc801}} 
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{Stereo\+Camera()}{StereoCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily Stereo\+Camera\+::\+Stereo\+Camera (\begin{DoxyParamCaption}\item[{bool}]{rectify = {\ttfamily true} }\end{DoxyParamCaption})}



Default Constructor. 

You should initialize all the intrinsic and extrinsic parameters using the provided methods. 

Definition at line 116 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
116                                        \{
117     this->rectify=rectify;
118     this->epipolarTh=0.01;
119     this->cameraChanged = \textcolor{keyword}{true};
120 
121 \textcolor{preprocessor}{#if !defined(USING\_GPU) && !defined(OPENCV\_GREATER\_2)}
122     cv::initModule\_nonfree();
123 \textcolor{preprocessor}{#endif }
124 
125 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a0c2cd4c7b5a0cdb96370c29a42601f40}} 
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{Stereo\+Camera()}{StereoCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily Stereo\+Camera\+::\+Stereo\+Camera (\begin{DoxyParamCaption}\item[{yarp\+::os\+::\+Resource\+Finder \&}]{rf,  }\item[{bool}]{rectify = {\ttfamily true} }\end{DoxyParamCaption})}



Costructor for initialization from file. 


\begin{DoxyParams}{Parameters}
{\em rf} & is the config file generated by the stereo\+Calib module. \\
\hline
\end{DoxyParams}


Definition at line 128 of file stereo\+Camera.\+cpp.



References set\+Intrinsics(), set\+Rotation(), and set\+Translation().


\begin{DoxyCode}
128                                                                  \{
129     Mat KL, KR, DistL, DistR, R, T;
130     loadStereoParameters(rf,KL,KR,DistL,DistR,R,T);
131     this->setIntrinsics(KL,KR,DistL,DistR);
132     this->setRotation(R,0);
133     this->setTranslation(T,0);
134 
135     this->cameraChanged=\textcolor{keyword}{true};
136     this->epipolarTh=0.01;
137     this->rectify=rectify;
138     buildUndistortRemap();
139 
140 \textcolor{preprocessor}{#if !defined(USING\_GPU) && !defined(OPENCV\_GREATER\_2)}
141     cv::initModule\_nonfree();
142 \textcolor{preprocessor}{#endif }
143 
144 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a5bfcf3ef7c9d45802bacbf040e7ca112}} 
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{Stereo\+Camera()}{StereoCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily Stereo\+Camera\+::\+Stereo\+Camera (\begin{DoxyParamCaption}\item[{\hyperlink{classCamera}{Camera}}]{First,  }\item[{\hyperlink{classCamera}{Camera}}]{Second,  }\item[{bool}]{rectify = {\ttfamily true} }\end{DoxyParamCaption})}



Constructor for initialization using two calibrated cameras. 

\begin{DoxyNote}{Note}
Only intrinsic parameters are initialized. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em First} & the first camera (Left eye is assumed but you can use any arbitrary camera). The 3D point coordinates have this reference system. \\
\hline
{\em Second} & the second camera (Right eye is assumed). \\
\hline
\end{DoxyParams}


Definition at line 147 of file stereo\+Camera.\+cpp.



References Camera\+::get\+Camera\+Matrix(), and Camera\+::get\+Dist\+Vector().


\begin{DoxyCode}
147                                                                  \{
148     this->Kleft=Left.getCameraMatrix();
149     this->DistL=Left.getDistVector();
150 
151     this->Kright=Right.getCameraMatrix();
152     this->DistR=Right.getDistVector();
153     this->cameraChanged=\textcolor{keyword}{true};
154     this->rectify=rectify;
155     this->epipolarTh=0.01;
156     buildUndistortRemap();
157 
158 \textcolor{preprocessor}{#if !defined(USING\_GPU) && !defined(OPENCV\_GREATER\_2)}
159     cv::initModule\_nonfree();
160 \textcolor{preprocessor}{#endif }
161 
162 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\label{classStereoCamera_aefb25fc2ecd8d0ce484e5981769dd635}} 
\index{Stereo\+Camera@{Stereo\+Camera}!chierality@{chierality}}
\index{chierality@{chierality}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{chierality()}{chierality()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::chierality (\begin{DoxyParamCaption}\item[{Mat \&}]{R1,  }\item[{Mat \&}]{R2,  }\item[{Mat \&}]{t1,  }\item[{Mat \&}]{t2,  }\item[{Mat \&}]{R,  }\item[{Mat \&}]{t,  }\item[{vector$<$ Point2f $>$}]{points1,  }\item[{vector$<$ Point2f $>$}]{points2 }\end{DoxyParamCaption})}



It performs the chierality test\+: given a couple of rotation matrices, translation vectors and matches it finds the correct rotation and translation s.\+t. 

the triangulated points have their depth coordinates greater than 0. The method is used by essential\+Decomposition, indeed an essential matrix generates 2 rotations and 2 translation. The chierality test is needed in order to discard wrong rototranslations. 
\begin{DoxyParams}{Parameters}
{\em R1} & first rotation 3x3 matrix \\
\hline
{\em R2} & second rotation 3x3 matrix \\
\hline
{\em t1} & first translation 3x1 matrix \\
\hline
{\em t2} & second translation 3x1 matrix \\
\hline
{\em R} & output rotation matrix \\
\hline
{\em t} & output translation matrix \\
\hline
{\em points1} & corrispondences in the first image \\
\hline
{\em points2} & corrispondences in the second image \\
\hline
\end{DoxyParams}


Definition at line 1171 of file stereo\+Camera.\+cpp.



References triangulation().



Referenced by essential\+Decomposition().


\begin{DoxyCode}
1171                                                                                                            
                                 \{
1172 
1173     Mat A= Mat::eye(3,4,CV\_64FC1);
1174     Mat P1 = this->Kleft*Mat::eye(3, 4, CV\_64F);
1175 
1176     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R1.rows; i++)
1177     \{
1178         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1179         \textcolor{keywordtype}{double}* MRi = R1.ptr<\textcolor{keywordtype}{double}>(i);
1180         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R1.cols; j++)
1181             Mi[j]=MRi[j];
1182     \}
1183 
1184     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t1.rows; i++)
1185     \{
1186         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1187         \textcolor{keywordtype}{double}* MRi = t1.ptr<\textcolor{keywordtype}{double}>(i);
1188         Mi[3]=MRi[0];
1189     \}
1190 
1191     Mat P2=this->Kright*A;
1192     A= Mat::eye(3,4,CV\_64FC1);
1193 
1194     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R2.rows; i++)
1195     \{
1196         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1197         \textcolor{keywordtype}{double}* MRi = R2.ptr<\textcolor{keywordtype}{double}>(i);
1198         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R2.cols; j++)
1199             Mi[j]=MRi[j];
1200     \}
1201     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t2.rows; i++)
1202     \{
1203         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1204         \textcolor{keywordtype}{double}* MRi = t2.ptr<\textcolor{keywordtype}{double}>(i);
1205         Mi[3]=MRi[0];
1206     \}
1207     Mat P3=this->Kright*A;
1208     A= Mat::eye(3,4,CV\_64FC1);
1209 
1210     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R1.rows; i++)
1211     \{
1212         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1213         \textcolor{keywordtype}{double}* MRi = R1.ptr<\textcolor{keywordtype}{double}>(i);
1214         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R1.cols; j++)
1215             Mi[j]=MRi[j];
1216     \}
1217     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t1.rows; i++)
1218     \{
1219         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1220         \textcolor{keywordtype}{double}* MRi = t2.ptr<\textcolor{keywordtype}{double}>(i);
1221         Mi[3]=MRi[0];
1222     \}
1223     Mat P4=this->Kright*A;
1224     A= Mat::eye(3,4,CV\_64FC1);
1225 
1226 
1227     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R2.rows; i++)
1228     \{
1229         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1230         \textcolor{keywordtype}{double}* MRi = R2.ptr<\textcolor{keywordtype}{double}>(i);
1231         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R2.cols; j++)
1232             Mi[j]=MRi[j];
1233     \}
1234     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t2.rows; i++)
1235     \{
1236         \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1237         \textcolor{keywordtype}{double}* MRi = t1.ptr<\textcolor{keywordtype}{double}>(i);
1238         Mi[3]=MRi[0];
1239     \}
1240     Mat P5=this->Kright*A;
1241 
1242     \textcolor{keywordtype}{int} err1=0; \textcolor{comment}{//R1 t1}
1243     \textcolor{keywordtype}{int} err2=0; \textcolor{comment}{//R2 t2}
1244     \textcolor{keywordtype}{int} err3=0; \textcolor{comment}{//R1 t2}
1245     \textcolor{keywordtype}{int} err4=0; \textcolor{comment}{//R2 t1}
1246     Mat point(4,1,CV\_64FC1);
1247 
1248     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int) InliersL.size(); i++)
1249     \{
1250         Point3f point3D=triangulation(points1[i],points2[i],P1,P2);
1251         Mat H1=buildRotTras(R1,t1);
1252         point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1253         point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1254         point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1255         point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1256         Mat rotatedPoint=H1*point;
1257         \textcolor{comment}{//fprintf(stdout, "Camera P2 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1258 
1259         \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1260             err1++;
1261         \}
1262         point3D=triangulation(points1[i],points2[i],P1,P3);
1263         Mat H2=buildRotTras(R2,t2);
1264         point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1265         point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1266         point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1267         point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1268         rotatedPoint=H2*point;
1269         \textcolor{comment}{//fprintf(stdout, "Camera P3 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1270 
1271         \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1272             err2++;
1273         \}
1274 
1275         point3D=triangulation(points1[i],points2[i],P1,P4);
1276         Mat H3=buildRotTras(R1,t2);
1277         point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1278         point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1279         point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1280         point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1281         rotatedPoint=H3*point;
1282         \textcolor{comment}{//fprintf(stdout, "Camera P4 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1283 
1284         \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1285             err3++;
1286         \}
1287 
1288         point3D=triangulation(points1[i],points2[i],P1,P5);
1289         Mat H4=buildRotTras(R2,t1);
1290         point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1291         point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1292         point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1293         point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1294         rotatedPoint=H4*point;
1295         \textcolor{comment}{//fprintf(stdout, "Camera P5 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1296 
1297         \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1298             err4++;
1299         \}
1300 
1301     \}
1302 
1303     \textcolor{comment}{/*printMatrix(R1);}
1304 \textcolor{comment}{    printMatrix(t1);}
1305 \textcolor{comment}{    printMatrix(R2);}
1306 \textcolor{comment}{    printMatrix(t2);*/}
1307     \textcolor{comment}{//fprintf(stdout, "Inliers: %d, %d, \(\backslash\)n",points1.size(),points2.size());}
1308     \textcolor{comment}{//fprintf(stdout, "errors: %d, %d, %d, %d, \(\backslash\)n",err1,err2,err3,err4);}
1309 
1310     \textcolor{keywordtype}{double} minErr=10000;
1311     \textcolor{keywordtype}{double} secondErr=minErr;
1312 
1313     \textcolor{keywordtype}{int} idx=0;
1314     \textcolor{keywordflow}{if}(err1<minErr && t1.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1315     \{
1316         idx=1;
1317         secondErr=minErr;
1318         minErr=err1;
1319     \}
1320 
1321     \textcolor{keywordflow}{if}(err2<minErr && t2.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1322     \{
1323         idx=2;
1324         secondErr=minErr;
1325         minErr=err2;
1326     \}
1327     \textcolor{keywordflow}{if}(err3<minErr && t2.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1328     \{
1329         idx=3;
1330         secondErr=minErr;
1331         minErr=err3;
1332     \}
1333     \textcolor{keywordflow}{if}(err4<minErr && t1.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1334     \{
1335         idx=4;
1336         secondErr=minErr;
1337         minErr=err4;
1338     \}
1339 
1340     \textcolor{comment}{/*if(secondErr==minErr)}
1341 \textcolor{comment}{      \{}
1342 \textcolor{comment}{        R=this->R;}
1343 \textcolor{comment}{        t=this->T;}
1344 \textcolor{comment}{        return;      }
1345 \textcolor{comment}{      \}*/}
1346     \textcolor{keywordflow}{if}(idx==1) \{
1347         R=R1;
1348         t=t1;
1349         \textcolor{keywordflow}{return};
1350     \}
1351     \textcolor{keywordflow}{if}(idx==2) \{
1352         R=R2;
1353         t=t2;
1354         \textcolor{keywordflow}{return};
1355     \}
1356     \textcolor{keywordflow}{if}(idx==3) \{
1357         R=R1;
1358         t=t2;
1359         \textcolor{keywordflow}{return};
1360     \}
1361     \textcolor{keywordflow}{if}(idx==4) \{
1362         R=R2;
1363         t=t1;
1364         \textcolor{keywordflow}{return};
1365     \}
1366 
1367 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}} 
\index{Stereo\+Camera@{Stereo\+Camera}!compute\+Disparity@{compute\+Disparity}}
\index{compute\+Disparity@{compute\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{compute\+Disparity()}{computeDisparity()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::compute\+Disparity (\begin{DoxyParamCaption}\item[{bool}]{best = {\ttfamily true},  }\item[{int}]{uniqueness\+Ratio = {\ttfamily 15},  }\item[{int}]{speckle\+Window\+Size = {\ttfamily 50},  }\item[{int}]{speckle\+Range = {\ttfamily 16},  }\item[{int}]{number\+Of\+Disparities = {\ttfamily 64},  }\item[{int}]{S\+A\+D\+Window\+Size = {\ttfamily 7},  }\item[{int}]{min\+Disparity = {\ttfamily 0},  }\item[{int}]{pre\+Filter\+Cap = {\ttfamily 63},  }\item[{int}]{disp12\+Max\+Diff = {\ttfamily 0} }\end{DoxyParamCaption})}



It computes the Disparity Map (see stereo\+Disparity). 


\begin{DoxyParams}{Parameters}
{\em best} & set equal true for better accuracy, equal false for save computation. \\
\hline
{\em uniqueness\+Ratio} & The margin in percents by which the best (minimum) computed cost function value should win the second best value to consider the found match correct. Normally, some value within 5-\/15 range is good enough. \\
\hline
{\em speckle\+Window\+Size} & Maximum size of smooth disparity regions to consider them noise speckles and invdalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in 50-\/200 range. \\
\hline
{\em speckle\+Range} & Maximum disparity variation within each connected component. If you do speckle filtering, set it to some positive value, multiple of 16. Normally, 16 or 32 is good enough. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Run the calibration or set all the parameters before using this method. 
\end{DoxyNote}


Definition at line 581 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
584 \{
585 
586     \textcolor{keywordflow}{if} (this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty())
587     \{
588         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
589         \textcolor{keywordflow}{return};
590     \}
591 
592     \textcolor{keywordflow}{if} (this->imleft.empty() || this->imright.empty())
593     \{
594         cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
595         \textcolor{keywordflow}{return};
596     \}
597 
598     Size img\_size=this->imleft.size();
599 
600     \textcolor{keywordflow}{if} (cameraChanged)
601     \{
602         lock\_guard<mutex> lg(mtx);
603         stereoRectify(this->Kleft, this->DistL, this->Kright, this->DistR, img\_size,
604                 this->R, this->T, this->RLrect, this->RRrect, this->PLrect,
605                 this->PRrect, this->Q, -1);
606 
607         \textcolor{keywordflow}{if} (!rectify)
608         \{
609             this->RLrect=Mat::eye(3,3,CV\_32FC1);
610             this->RRrect=Mat::eye(3,3,CV\_32FC1);
611             this->PLrect=this->Kleft;
612             this->PRrect=this->Kright;
613         \}
614     \}
615 
616     \textcolor{keywordflow}{if} (cameraChanged)
617     \{
618         initUndistortRectifyMap(this->Kleft, this->DistL, this->RLrect, this->PLrect,
619                 img\_size, CV\_32FC1, this->map11, this->map12);
620         initUndistortRectifyMap(this->Kright,  this->DistR, this->RRrect, this->PRrect,
621                 img\_size, CV\_32FC1, this->map21, this->map22);
622     \}
623 
624     Mat img1r, img2r;
625     remap(this->imleft, img1r, this->map11, this->map12, cv::INTER\_LINEAR);
626     remap(this->imright, img2r, this->map21,this->map22, cv::INTER\_LINEAR);
627 
628     imgLeftRect = img1r;
629     imgRightRect = img2r;
630 
631     Mat disp,disp8,map,dispTemp;
632 
633     \textcolor{keywordtype}{bool} success;
634 
635     \textcolor{keywordflow}{if} (use\_elas)
636     \{
637         success = elaswrap->compute\_disparity(img1r, img2r, disp, numberOfDisparities);
638         \textcolor{keywordflow}{if} (success)
639         \{
640             map = disp * (255.0 / numberOfDisparities);
641             \textcolor{comment}{//threshold(map, map, 0, 255.0, THRESH\_TOZERO);}
642         \}
643     \} \textcolor{keywordflow}{else}
644     \{
645         \textcolor{keywordtype}{int} cn=this->imleft.channels();
646 \textcolor{preprocessor}{    #ifdef OPENCV\_GREATER\_2}
647         Ptr<StereoSGBM> sgbm=cv::StereoSGBM::create(minDisparity,numberOfDisparities,SADWindowSize,
648                                                     8*cn*SADWindowSize*SADWindowSize,
649                                                     32*cn*SADWindowSize*SADWindowSize,
650                                                     disp12MaxDiff,preFilterCap,uniquenessRatio,
651                                                     speckleWindowSize,speckleRange,
652                                                     best?StereoSGBM::MODE\_HH:StereoSGBM::MODE\_SGBM);
653         sgbm->compute(img1r, img2r, disp);
654 \textcolor{preprocessor}{    #else}
655         StereoSGBM sgbm;
656         sgbm.preFilterCap =         preFilterCap; \textcolor{comment}{//63}
657         sgbm.SADWindowSize =        SADWindowSize;        
658         sgbm.P1 =                   8*cn*SADWindowSize*SADWindowSize;
659         sgbm.P2 =                   32*cn*SADWindowSize*SADWindowSize;
660         sgbm.minDisparity =         minDisparity; \textcolor{comment}{//-15}
661         sgbm.numberOfDisparities =  numberOfDisparities;
662         sgbm.uniquenessRatio =      uniquenessRatio; \textcolor{comment}{//22}
663         sgbm.speckleWindowSize =    speckleWindowSize; \textcolor{comment}{//100}
664         sgbm.speckleRange =         speckleRange; \textcolor{comment}{//32}
665         sgbm.disp12MaxDiff =        disp12MaxDiff;
666         sgbm.fullDP =               best; \textcolor{comment}{// alg == STEREO\_HH}
667 
668         sgbm(img1r, img2r, disp);
669 \textcolor{preprocessor}{    #endif}
670 
671         disp.convertTo(map, CV\_32FC1, 1.0,0.0);
672         map.convertTo(map,CV\_32FC1,255/(numberOfDisparities*16.));
673         \textcolor{comment}{//normalize(map,map, 0, 255, cv::NORM\_MINMAX, CV\_8UC1);}
674 
675         success = \textcolor{keyword}{true};
676     \}
677 
678     \textcolor{keywordflow}{if} (success)
679     \{
680         \textcolor{keywordflow}{if} (cameraChanged)
681         \{
682             lock\_guard<mutex> lg(mtx);
683             Mat inverseMapL(map.rows*map.cols,1,CV\_32FC2);
684             Mat inverseMapR(map.rows*map.cols,1,CV\_32FC2);
685 
686             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y=0; y<map.rows; y++)
687             \{
688                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x=0; x<map.cols; x++)
689                 \{
690                     inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[0]=(\textcolor{keywordtype}{float})x;
691                     inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[1]=(\textcolor{keywordtype}{float})y;
692                     inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[0]=(\textcolor{keywordtype}{float})x;
693                     inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[1]=(\textcolor{keywordtype}{float})y;
694                 \}
695             \}
696 
697             undistortPoints(inverseMapL,inverseMapL,this->Kleft,this->DistL,this->RLrect,this->PLrect);
698             undistortPoints(inverseMapR,inverseMapR,this->Kright,this->DistR,this->RRrect,this->PRrect);
699 
700             Mat mapperL=inverseMapL.reshape(2,map.rows);
701             Mat mapperR=inverseMapR.reshape(2,map.rows);
702             this->MapperL=mapperL;
703             this->MapperR=mapperR;
704 
705             cameraChanged = \textcolor{keyword}{false};
706         \}
707 
708         Mat x;
709         remap(map,dispTemp,this->MapperL,x,cv::INTER\_LINEAR);
710         dispTemp.convertTo(disp8,CV\_8U);
711 
712         \textcolor{keywordflow}{if} (use\_elas)
713             disp.convertTo(disp, CV\_16SC1, 16.0);
714     \}
715 
716     lock\_guard<mutex> lg(mtx);
717     this->Disparity = disp8;
718     this->Disparity16 = disp;
719 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a52ef2f3401488e5c4fa6badd1336f96d}} 
\index{Stereo\+Camera@{Stereo\+Camera}!compute\+World\+Image@{compute\+World\+Image}}
\index{compute\+World\+Image@{compute\+World\+Image}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{compute\+World\+Image()}{computeWorldImage()}}
{\footnotesize\ttfamily Mat Stereo\+Camera\+::compute\+World\+Image (\begin{DoxyParamCaption}\item[{Mat \&}]{H }\end{DoxyParamCaption})}



The method returns a 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. 


\begin{DoxyParams}{Parameters}
{\em H} & the transformation from the camera reference system to the H reference system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. 
\end{DoxyReturn}


Definition at line 2231 of file stereo\+Camera.\+cpp.



References get\+R\+Lrect().


\begin{DoxyCode}
2232 \{
2233     Mat worldImg(Disparity16.rows,Disparity16.cols,CV\_32FC3);
2234 
2235     \textcolor{keywordflow}{if}(H.empty())
2236         H=H.eye(4,4,CV\_64FC1);
2237 
2238     \textcolor{keywordflow}{if}(Disparity16.empty() || MapperL.empty() || Q.empty())
2239     \{
2240         cout <<\textcolor{stringliteral}{" Run computeDisparity() method first"} << endl;
2241         \textcolor{keywordflow}{return} worldImg;
2242     \}
2243 
2244     Mat dispTemp;
2245     Mat x;
2246     remap(this->Disparity16,dispTemp,this->MapperL,x,cv::INTER\_LINEAR);
2247     reprojectImageTo3D(dispTemp, worldImg,this->Q,\textcolor{keyword}{true});
2248 
2249     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<worldImg.rows; i++)
2250     \{
2251         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<worldImg.cols; j++)
2252         \{
2253             Mat RLrectTmp=this->getRLrect().t();
2254             Mat Tfake = Mat::zeros(0,3,CV\_64F);
2255             Mat P(4,1,CV\_64FC1);
2256             \textcolor{keywordflow}{if}((worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2]>100)
2257             \{
2258                 P.at<\textcolor{keywordtype}{double}>(0,0)=0.0;
2259                 P.at<\textcolor{keywordtype}{double}>(1,0)=0.0;
2260                 P.at<\textcolor{keywordtype}{double}>(2,0)=0.0;
2261                 P.at<\textcolor{keywordtype}{double}>(3,0)=1.0;
2262             \}
2263             \textcolor{keywordflow}{else}
2264             \{
2265                 P.at<\textcolor{keywordtype}{double}>(0,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 0];
2266                 P.at<\textcolor{keywordtype}{double}>(1,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 1];
2267                 P.at<\textcolor{keywordtype}{double}>(2,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2];
2268                 P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2269 
2270                 Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2271                 P=H*Hrect*P;
2272             \}
2273             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 0]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2274             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 1]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2275             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2276         \}
2277     \}
2278 
2279     \textcolor{keywordflow}{return} worldImg;
2280 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a6580ff03c7cec5c385ec717f9c018e21}} 
\index{Stereo\+Camera@{Stereo\+Camera}!draw\+Matches@{draw\+Matches}}
\index{draw\+Matches@{draw\+Matches}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{draw\+Matches()}{drawMatches()}}
{\footnotesize\ttfamily Mat Stereo\+Camera\+::draw\+Matches (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



The method returns a 3-\/\+Channels 8bit image with the image matches. 

\begin{DoxyReturn}{Returns}
The 3-\/\+Channels 8bit image with the image matches. Call \hyperlink{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}{find\+Match()} to retrieve the keypoints first. 
\end{DoxyReturn}


Definition at line 1668 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1669 \{
1670     \textcolor{keywordflow}{if} (this->imleftund.empty() || this->imrightund.empty())
1671     \{
1672         imleftund=imleft;
1673         imrightund=imright;
1674     \}
1675 
1676     Mat matchImg;
1677     vector<KeyPoint> keypoints1(InliersL.size());
1678     vector<KeyPoint> keypoints2(InliersL.size());
1679     vector<DMatch> filteredMatches(InliersL.size());
1680 
1681     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<InliersL.size(); i++)
1682     \{
1683         filteredMatches[i].queryIdx=i;
1684         filteredMatches[i].trainIdx=i;
1685 
1686         keypoints1[i]=cv::KeyPoint(InliersL[i],2);
1687         keypoints2[i]=cv::KeyPoint(InliersR[i],2);
1688     \}
1689 
1690     cv::drawMatches(this->imleftund,keypoints1,this->imrightund,keypoints2,
1691             filteredMatches,matchImg,Scalar(0,0,255,0),Scalar(0,0,255,0));
1692 
1693     \textcolor{keywordflow}{return} matchImg;
1694 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a180388e93b654802c7c56c18d206214b}} 
\index{Stereo\+Camera@{Stereo\+Camera}!essential\+Decomposition@{essential\+Decomposition}}
\index{essential\+Decomposition@{essential\+Decomposition}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{essential\+Decomposition()}{essentialDecomposition()}}
{\footnotesize\ttfamily bool Stereo\+Camera\+::essential\+Decomposition (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



It decomposes the essential matrix in Rotation and Translation between the two views. 

The output is stored in the private members R and T. 

Definition at line 1071 of file stereo\+Camera.\+cpp.



References chierality().


\begin{DoxyCode}
1072 \{
1073     \textcolor{keywordflow}{if} (E.empty())
1074     \{
1075         cout << \textcolor{stringliteral}{"Essential Matrix is empty! Run the estimateEssential first!"} << endl;
1076         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1077     \}
1078 
1079     \textcolor{keywordflow}{if} (this->InliersL.empty())
1080     \{
1081         cout << \textcolor{stringliteral}{"No matches in memory! Run findMatch first!"} << endl;
1082         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1083     \}
1084 
1085     Mat W=Mat(3,3,CV\_64FC1);
1086     W.setTo(0);
1087     W.at<\textcolor{keywordtype}{double}>(0,0)=0;
1088     W.at<\textcolor{keywordtype}{double}>(0,1)=-1;
1089     W.at<\textcolor{keywordtype}{double}>(0,2)=0;
1090 
1091     W.at<\textcolor{keywordtype}{double}>(1,0)=1;
1092     W.at<\textcolor{keywordtype}{double}>(1,1)=0;
1093     W.at<\textcolor{keywordtype}{double}>(1,2)=0;
1094 
1095     W.at<\textcolor{keywordtype}{double}>(2,0)=0;
1096     W.at<\textcolor{keywordtype}{double}>(2,1)=0;
1097     W.at<\textcolor{keywordtype}{double}>(2,2)=1;
1098 
1099     SVD dec(E);
1100 
1101     Mat Y=Mat::eye(3,3,CV\_64FC1);
1102     Y.at<\textcolor{keywordtype}{double}>(2,2)=0.0;
1103     E=dec.u*Y*dec.vt; \textcolor{comment}{// projection to the Essential Matrix space}
1104 
1105     dec(E);
1106 
1107     Mat V=dec.vt;
1108     Mat U=dec.u;
1109 
1110     Mat R1=U*W*V;
1111     Mat R2=U*W.t()*V;
1112 
1113     \textcolor{keywordflow}{if} (determinant(R1)<0 || determinant(R2)<0)
1114     \{
1115         E=-E;
1116         SVD dec2(E);
1117 
1118         V=dec2.vt;
1119         U=dec2.u;
1120 
1121         R1=U*W*V;
1122         R2=U*W.t()*V;
1123     \}
1124 
1125     Mat t1=U(Range(0,3),Range(2,3));
1126     Mat t2=-t1;
1127 
1128     Mat Rnew=Mat(3,3,CV\_64FC1);
1129     Rnew.setTo(0);
1130     Mat tnew=Mat(3,1,CV\_64FC1);
1131 
1132     chierality(R1,R2,t1,t2,Rnew,tnew,this->InliersL,this->InliersR);
1133 
1134     Mat rvec\_new=Mat::zeros(3,1,CV\_64FC1);
1135     Mat rvec\_exp=Mat::zeros(3,1,CV\_64FC1);
1136     Rodrigues(Rnew,rvec\_new);
1137     Rodrigues(R\_exp,rvec\_exp);
1138 
1139     Mat t\_est=(tnew/norm(tnew))*norm(this->T);
1140 
1141     Mat diff\_angles=rvec\_exp-rvec\_new;
1142     Mat diff\_tran=T\_exp-t\_est;
1143 
1144     std::cout << \textcolor{stringliteral}{"[StereoCamera] Angles Differences: "} << diff\_angles.at<\textcolor{keywordtype}{double}>(0,0) << \textcolor{stringliteral}{" "} <<
1145                                                           diff\_angles.at<\textcolor{keywordtype}{double}>(1,0) << \textcolor{stringliteral}{" "} <<
1146                                                           diff\_angles.at<\textcolor{keywordtype}{double}>(2,0) << std::endl;
1147 
1148     std::cout << \textcolor{stringliteral}{"[StereoCamera] Translation Differences: "} << diff\_tran.at<\textcolor{keywordtype}{double}>(0,0) << \textcolor{stringliteral}{" "} <<
1149                                                                diff\_tran.at<\textcolor{keywordtype}{double}>(1,0) << \textcolor{stringliteral}{" "} <<
1150                                                                diff\_tran.at<\textcolor{keywordtype}{double}>(2,0) << std::endl;
1151 
1152 
1153 
1154     \textcolor{comment}{// Magic numbers: rvec\_new are the rotation angles, only vergence (rvec\_new(1,0)) is allowed to be
       large}
1155     \textcolor{comment}{// t\_est is the translation estimated, it can change a little bit when joint 4 of the head is moving}
1156     \textcolor{keywordflow}{if} (fabs(diff\_angles.at<\textcolor{keywordtype}{double}>(0,0))<0.15 && fabs(diff\_angles.at<\textcolor{keywordtype}{double}>(1,0))<0.15 && fabs(
      diff\_angles.at<\textcolor{keywordtype}{double}>(2,0))<0.15 &&
1157             fabs(diff\_tran.at<\textcolor{keywordtype}{double}>(0,0))<0.01 && fabs(diff\_tran.at<\textcolor{keywordtype}{double}>(1,0))<0.01  && fabs(diff\_tran
      .at<\textcolor{keywordtype}{double}>(2,0))<0.01)
1158     \{
1159         lock\_guard<mutex> lg(mtx);
1160         this->R=Rnew;
1161         this->T=t\_est;
1162         this->updatePMatrix();
1163         this->cameraChanged=\textcolor{keyword}{true};
1164         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1165     \}
1166     \textcolor{keywordflow}{else}
1167         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1168 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ab2eded08bca185ac22cd6343cb4c85c8}} 
\index{Stereo\+Camera@{Stereo\+Camera}!estimate\+Essential@{estimate\+Essential}}
\index{estimate\+Essential@{estimate\+Essential}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{estimate\+Essential()}{estimateEssential()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::estimate\+Essential (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



It estimates the essential matrix (3x3) E between two views. 

The output is stored in the private member E. 

Definition at line 965 of file stereo\+Camera.\+cpp.



References Ffrom\+P().


\begin{DoxyCode}
966 \{
967     this->InliersL.clear();
968     this->InliersR.clear();
969 
970     \textcolor{keywordflow}{if} (this->PointsL.size()<10 || this->PointsL.size()<10 )
971     \{
972         cout << \textcolor{stringliteral}{"Not enough matches in memory! Run findMatch first!"} << endl;
973         this->E=Mat(3,3,CV\_64FC1);
974         \textcolor{keywordflow}{return};
975     \}
976 
977     updateExpectedCameraMatrices();
978     Mat F\_exp=FfromP(Pleft\_exp,Pright\_exp);
979 
980     vector<Point2f> filteredL;
981     vector<Point2f> filteredR;
982 
983     std::cout << \textcolor{stringliteral}{"[StereoCamera] "} << PointsR.size() << \textcolor{stringliteral}{" Matches Found."} << std::endl;
984 
985     Mat pl=Mat(3,1,CV\_64FC1);
986     Mat pr=Mat(3,1,CV\_64FC1);
987 
988     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<(int) PointsL.size(); i++)
989     \{
990         pl.at<\textcolor{keywordtype}{double}>(0,0)=PointsL[i].x;
991         pl.at<\textcolor{keywordtype}{double}>(1,0)=PointsL[i].y;
992         pl.at<\textcolor{keywordtype}{double}>(2,0)=1;
993 
994         pr.at<\textcolor{keywordtype}{double}>(0,0)=PointsR[i].x;
995         pr.at<\textcolor{keywordtype}{double}>(1,0)=PointsR[i].y;
996         pr.at<\textcolor{keywordtype}{double}>(2,0)=1;
997 
998         Mat xrFxl=pr.t()*F\_exp*pl;
999         Mat Fxl=F\_exp*pl;
1000         Mat Fxr=F\_exp.t()*pr;
1001 
1002         pow(xrFxl,2,xrFxl);
1003 
1004         pow(Fxl,2,Fxl);
1005 
1006         pow(Fxr,2,Fxr);
1007 
1008         Scalar den1,den2;
1009         den1=sum(Fxl);
1010         den2=sum(Fxr);
1011         \textcolor{keywordtype}{double} sampsonDistance=xrFxl.at<\textcolor{keywordtype}{double}>(0,0)/(den1.val[0]+den2.val[0]);
1012 
1013         \textcolor{keywordflow}{if} (sampsonDistance<0.1)
1014         \{
1015             filteredL.push\_back(PointsL[i]);
1016             filteredR.push\_back(PointsR[i]);
1017         \}
1018     \}
1019 
1020     std::cout << \textcolor{stringliteral}{"[StereoCamera] "} << filteredL.size() << \textcolor{stringliteral}{" Matches Left After Kinematics Filtering."} << 
      std::endl;
1021 
1022     vector<uchar> status;
1023     this->F=findFundamentalMat(Mat(filteredL), Mat(filteredR), status, CV\_FM\_8POINT, 1, 0.999);
1024 
1025     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<(int) filteredL.size(); i++)
1026     \{
1027         pl.at<\textcolor{keywordtype}{double}>(0,0)=filteredL[i].x;
1028         pl.at<\textcolor{keywordtype}{double}>(1,0)=filteredL[i].y;
1029         pl.at<\textcolor{keywordtype}{double}>(2,0)=1;
1030 
1031         pr.at<\textcolor{keywordtype}{double}>(0,0)=filteredR[i].x;
1032         pr.at<\textcolor{keywordtype}{double}>(1,0)=filteredR[i].y;
1033         pr.at<\textcolor{keywordtype}{double}>(2,0)=1;
1034 
1035         Mat xrFxl=pr.t()*F*pl;
1036         Mat Fxl=F*pl;
1037         Mat Fxr=F.t()*pr;
1038 
1039         pow(xrFxl,2,xrFxl);
1040         pow(Fxl,2,Fxl);
1041         pow(Fxr,2,Fxr);
1042 
1043         Scalar den1,den2;
1044         den1=sum(Fxl);
1045         den2=sum(Fxr);
1046 
1047         \textcolor{keywordflow}{if} (status[i]==1 && xrFxl.at<\textcolor{keywordtype}{double}>(0,0)<0.001)
1048         \{
1049             InliersL.push\_back(filteredL[i]);
1050             InliersR.push\_back(filteredR[i]);
1051         \}
1052     \}
1053 
1054     std::cout << \textcolor{stringliteral}{"[StereoCamera] "} << InliersL.size() << \textcolor{stringliteral}{" Matches Left After RANSAC Filtering."} << 
      std::endl;
1055 
1056     \textcolor{keywordflow}{if} (this->InliersL.size()<10 || this->InliersR.size()<10 )
1057     \{
1058         InliersL.clear();
1059         InliersR.clear();
1060         cout << \textcolor{stringliteral}{"Not enough matches in memory! Run findMatch first!"} << endl;
1061         this->E=Mat(3,3,CV\_64FC1);
1062         \textcolor{keywordflow}{return};
1063     \}
1064 
1065     this->F=findFundamentalMat(Mat(InliersL), Mat(InliersR),status, CV\_FM\_8POINT, 1, 0.999);
1066     this->E=this->Kright.t()*this->F*this->Kleft;
1067 
1068 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a3fe4e87322f8644cd21ce06e8522c815}} 
\index{Stereo\+Camera@{Stereo\+Camera}!FfromP@{FfromP}}
\index{FfromP@{FfromP}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{Ffrom\+P()}{FfromP()}}
{\footnotesize\ttfamily Mat Stereo\+Camera\+::\+FfromP (\begin{DoxyParamCaption}\item[{Mat \&}]{P1,  }\item[{Mat \&}]{P2 }\end{DoxyParamCaption})}



The function computes the fundamental matrix starting from known camera matrices. 


\begin{DoxyParams}{Parameters}
{\em P1} & a 3x4 matrix representing the camera matrix of the left view. \\
\hline
{\em P2} & a 3x4 matrix representing the camera matrix of the right view. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3x3 matrix representing the fundamental matrix. 
\end{DoxyReturn}


Definition at line 890 of file stereo\+Camera.\+cpp.



Referenced by estimate\+Essential().


\begin{DoxyCode}
891 \{
892     Mat F\_true(3,3,CV\_64FC1);
893 
894     Mat X1(2,4,CV\_64FC1);
895     Mat X2(2,4,CV\_64FC1);
896     Mat X3(2,4,CV\_64FC1);
897 
898     Mat Y1(2,4,CV\_64FC1);
899     Mat Y2(2,4,CV\_64FC1);
900     Mat Y3(2,4,CV\_64FC1);
901 
902 
903     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<P1.rows; i++)
904     \{
905         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<P1.cols; j++)
906         \{
907             \textcolor{keywordflow}{if}(i==0)
908             \{
909                 X2.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
910                 X3.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
911                 Y2.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
912                 Y3.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
913             \}
914             \textcolor{keywordflow}{if}(i==1)
915             \{
916                 X1.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
917                 X3.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
918                 Y1.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
919                 Y3.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
920             \}
921 
922             \textcolor{keywordflow}{if}(i==2)
923             \{
924                 X1.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
925                 X2.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
926                 Y1.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
927                 Y2.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
928 
929             \}
930         \}
931     \}
932 
933 
934     std::vector<Mat> MatX;
935     std::vector<Mat> MatY;
936 
937     MatX.push\_back(X1);
938     MatX.push\_back(X2);
939     MatX.push\_back(X3);
940 
941     MatY.push\_back(Y1);
942     MatY.push\_back(Y2);
943     MatY.push\_back(Y3);
944 
945 
946     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<F\_true.rows; i++)
947     \{
948         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<F\_true.cols; j++)
949         \{
950             Mat X=MatX[i];
951             Mat Y=MatY[j];
952 
953             Mat concatenated;
954 
955             cv::vconcat(X,Y,concatenated);
956 
957             F\_true.at<\textcolor{keywordtype}{double}>(j,i)=cv::determinant(concatenated);
958         \}
959     \}
960 
961     \textcolor{keywordflow}{return} F\_true;
962 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}} 
\index{Stereo\+Camera@{Stereo\+Camera}!find\+Match@{find\+Match}}
\index{find\+Match@{find\+Match}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{find\+Match()}{findMatch()}}
{\footnotesize\ttfamily Mat Stereo\+Camera\+::find\+Match (\begin{DoxyParamCaption}\item[{bool}]{visualize = {\ttfamily false},  }\item[{double}]{displacement = {\ttfamily 20.0},  }\item[{double}]{radius = {\ttfamily 200.0} }\end{DoxyParamCaption})}



It finds matches between two images. 

S\+I\+FT detector and descriptor is used. \begin{DoxyNote}{Note}
Run set\+Images and indistort\+Images methods before using this method. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em visualize} & true if you want to visualize matches between images \\
\hline
{\em displacement} & maximum pixel displacement between first and second camera \\
\hline
{\em radius} & maximum radius between the first candidate match and the second one \\
\hline
\end{DoxyParams}


Definition at line 750 of file stereo\+Camera.\+cpp.



References triangulation().


\begin{DoxyCode}
751 \{
752     \textcolor{keywordflow}{if} (this->imleftund.empty() || this->imrightund.empty())
753     \{
754         imleftund=imleft;
755         imrightund=imright;
756     \}
757 
758     this->PointsL.clear();
759     this->PointsR.clear();
760 
761     this->InliersL.clear();
762     this->InliersR.clear();
763 
764     Mat grayleft(imleftund.rows,imleftund.cols, CV\_8UC1);
765     imleftund.convertTo(grayleft,CV\_8UC1);
766 
767     Mat grayright(imrightund.rows,imrightund.cols,CV\_8UC1);
768     imrightund.convertTo(grayright,CV\_8UC1);
769 
770     vector<KeyPoint> keypoints1,keypoints2;
771     Mat descriptors1,descriptors2;
772 
773 \textcolor{preprocessor}{#ifdef OPENCV\_GREATER\_2}
774     Ptr<xfeatures2d::SIFT> sift=xfeatures2d::SIFT::create();
775     yAssert(sift!=NULL);
776 
777     sift->detect(grayleft,keypoints1);
778     sift->compute(grayleft,keypoints1,descriptors1);
779 
780     sift->detect(grayright,keypoints2);
781     sift->compute(grayright,keypoints2,descriptors2);
782 \textcolor{preprocessor}{#else}
783     Ptr<cv::FeatureDetector> detector=cv::FeatureDetector::create(\textcolor{stringliteral}{"SIFT"});
784     Ptr<cv::DescriptorExtractor> descriptorExtractor=cv::DescriptorExtractor::create(\textcolor{stringliteral}{"SIFT"});
785 
786     yAssert(detector!=NULL);
787     yAssert(descriptorExtractor!=NULL);
788 
789     detector->detect(grayleft,keypoints1);
790     descriptorExtractor->compute(grayleft,keypoints1,descriptors1);
791 
792     detector->detect(grayright,keypoints2);
793     descriptorExtractor->compute(grayright,keypoints2,descriptors2);
794 \textcolor{preprocessor}{#endif}
795     
796     cv::BFMatcher descriptorMatcher;
797     vector<DMatch> filteredMatches;
798     crossCheckMatching(descriptorMatcher,descriptors1,descriptors2,filteredMatches,radius);
799 
800     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<filteredMatches.size(); i++)
801     \{
802         Point2f pointL=keypoints1[filteredMatches[i].queryIdx].pt;
803         Point2f pointR=keypoints2[filteredMatches[i].trainIdx].pt;
804         \textcolor{keywordflow}{if} (fabs(pointL.y-pointR.y)<displacement)
805         \{
806             this->PointsR.push\_back(pointR);
807             this->PointsL.push\_back(pointL);
808         \}
809     \}
810 
811     Mat matchImg;
812     \textcolor{keywordflow}{if} (visualize)
813         cv::drawMatches(this->imleftund,keypoints1,this->imrightund,keypoints2,
814                 filteredMatches,matchImg,Scalar(0,0,255,0),Scalar(0,0,255,0));
815 
816     \textcolor{keywordflow}{return} matchImg;
817 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a3d8fde0cbd4604085b883f22cc606c01}} 
\index{Stereo\+Camera@{Stereo\+Camera}!from\+Rectified\+To\+Original@{from\+Rectified\+To\+Original}}
\index{from\+Rectified\+To\+Original@{from\+Rectified\+To\+Original}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{from\+Rectified\+To\+Original()}{fromRectifiedToOriginal()}}
{\footnotesize\ttfamily Point2f Stereo\+Camera\+::from\+Rectified\+To\+Original (\begin{DoxyParamCaption}\item[{int}]{u,  }\item[{int}]{v,  }\item[{int}]{camera }\end{DoxyParamCaption})}



Given the u,v pixel coordinates in the rectified image the method returns the position of the pixel in the non-\/rectified frame. 


\begin{DoxyParams}{Parameters}
{\em u} & the x pixel coordinate in the rectified image. \\
\hline
{\em v} & the y pixel coordinate in the rectified image. \\
\hline
{\em cam} & cam=1 for left image, cam=2 for right image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pixel position in the non-\/rectified image. 
\end{DoxyReturn}


Definition at line 722 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
723 \{
724     cv::Point2f originalPoint;
725 
726 
727     \textcolor{keywordflow}{if}(u>=map11.rows || u<0 || v>=map12.cols || v< 0)
728     \{
729         originalPoint.x=0;
730         originalPoint.y=0;
731         \textcolor{keywordflow}{return} originalPoint;
732     \}
733     \textcolor{keywordflow}{if}(camera==LEFT)
734     \{
735         originalPoint.x=map11.ptr<\textcolor{keywordtype}{float}>(v)[u];
736         originalPoint.y=map12.ptr<\textcolor{keywordtype}{float}>(v)[u];
737     \}
738     \textcolor{keywordflow}{else}
739     \{
740         originalPoint.x=map21.ptr<\textcolor{keywordtype}{float}>(v)[u];
741         originalPoint.y=map22.ptr<\textcolor{keywordtype}{float}>(v)[u];
742     \}
743 
744 
745     \textcolor{keywordflow}{return} originalPoint;
746 
747 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a74adec3c305b13df4757e105cd72a7db}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Disparity@{get\+Disparity}}
\index{get\+Disparity@{get\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Disparity()}{getDisparity()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Disparity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the disparity image. 

\begin{DoxyReturn}{Returns}
the disparity image computed via \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity()}. The image is 8 bit unsigned. 
\end{DoxyReturn}


Definition at line 533 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
533                                             \{
534     \textcolor{keywordflow}{return} this->Disparity;
535 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a4a6e408446750224499ed9ecdc51629e}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Disparity16@{get\+Disparity16}}
\index{get\+Disparity16@{get\+Disparity16}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Disparity16()}{getDisparity16()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Disparity16 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the disparity image. 

\begin{DoxyReturn}{Returns}
the disparity image computed via \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity()}. The image is 16 bit signed. 
\end{DoxyReturn}


Definition at line 538 of file stereo\+Camera.\+cpp.



Referenced by metric\+Triangulation().


\begin{DoxyCode}
538                                               \{
539     \textcolor{keywordflow}{return} this->Disparity16;
540 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_af9e52f941837f0db26d150d0ca4ff3bc}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Dist\+Coeff\+Left@{get\+Dist\+Coeff\+Left}}
\index{get\+Dist\+Coeff\+Left@{get\+Dist\+Coeff\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Dist\+Coeff\+Left()}{getDistCoeffLeft()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Dist\+Coeff\+Left (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the 5x1 left distortion coefficients. 

\begin{DoxyReturn}{Returns}
5x1 left distortion coefficients. 
\end{DoxyReturn}


Definition at line 2283 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2284 \{
2285     \textcolor{keywordflow}{return} this->DistL;
2286 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a589ca8eb4ebfc4377589a77bb15b85b7}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Dist\+Coeff\+Right@{get\+Dist\+Coeff\+Right}}
\index{get\+Dist\+Coeff\+Right@{get\+Dist\+Coeff\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Dist\+Coeff\+Right()}{getDistCoeffRight()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Dist\+Coeff\+Right (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the 5x1 right distortion coefficients. 

\begin{DoxyReturn}{Returns}
5x1 right distortion coefficients. 
\end{DoxyReturn}


Definition at line 2289 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2290 \{
2291     \textcolor{keywordflow}{return} this->DistR;
2292 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_af64550bb8a7a665930dee5eea87b7e47}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Distorted\+Pixel@{get\+Distorted\+Pixel}}
\index{get\+Distorted\+Pixel@{get\+Distorted\+Pixel}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Distorted\+Pixel()}{getDistortedPixel()}}
{\footnotesize\ttfamily Point2f Stereo\+Camera\+::get\+Distorted\+Pixel (\begin{DoxyParamCaption}\item[{int}]{u,  }\item[{int}]{v,  }\item[{int}]{cam = {\ttfamily 1} }\end{DoxyParamCaption})}



Given the u,v pixel coordinates in the undistorted image the method returns the original position of the pixel in the distorted frame. 


\begin{DoxyParams}{Parameters}
{\em u} & the x pixel coordinate in the undistorted image. \\
\hline
{\em v} & the y pixel coordinate in the undistorted image. \\
\hline
{\em cam} & cam=1 for left image, cam=2 for right image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pixel position in the distorted image. 
\end{DoxyReturn}


Definition at line 2305 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2306 \{
2307     Point2f distortedPixel;
2308     Mat MapperX,MapperY;
2309 
2310     \textcolor{keywordflow}{if}(cam==LEFT)
2311     \{
2312         MapperX=mapxL;
2313         MapperY=mapyL;
2314     \}
2315     \textcolor{keywordflow}{else}
2316     \{
2317         MapperX=mapxR;
2318         MapperY=mapyR;
2319     \}
2320     distortedPixel.x=MapperX.ptr<\textcolor{keywordtype}{float}>(v)[u];
2321     distortedPixel.y=MapperY.ptr<\textcolor{keywordtype}{float}>(v)[u];
2322 
2323     \textcolor{keywordflow}{return} distortedPixel;
2324 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ab02e0869a054fe23d2b56def81a1a947}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Fundamental@{get\+Fundamental}}
\index{get\+Fundamental@{get\+Fundamental}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Fundamental()}{getFundamental()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Fundamental (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the 3x3 fundamental matrix. 

\begin{DoxyReturn}{Returns}
3x3 fundamental matrix. 
\end{DoxyReturn}


Definition at line 1495 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1495                                               \{
1496     \textcolor{keywordflow}{return} this->F;
1497 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ac0cb76a6994bd7ab915cb02d83cf8f8e}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Left@{get\+Im\+Left}}
\index{get\+Im\+Left@{get\+Im\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Im\+Left()}{getImLeft()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Im\+Left (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the left (first) image. 

\begin{DoxyReturn}{Returns}
the left (first) image. 
\end{DoxyReturn}


Definition at line 523 of file stereo\+Camera.\+cpp.



Referenced by update\+Mappings().


\begin{DoxyCode}
523                                          \{
524     \textcolor{keywordflow}{return} this->imleft;
525 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a52ba4f0331f3690ca0f983b10bd0c783}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Left\+Und@{get\+Im\+Left\+Und}}
\index{get\+Im\+Left\+Und@{get\+Im\+Left\+Und}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Im\+Left\+Und()}{getImLeftUnd()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Im\+Left\+Und (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the left undistorted image. 

\begin{DoxyReturn}{Returns}
the left undistorted image. 
\end{DoxyReturn}


Definition at line 1490 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1490                                             \{
1491     \textcolor{keywordflow}{return} this->imleftund;
1492 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ac7930aa4fa0681246e74c08cf4b1079b}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Right@{get\+Im\+Right}}
\index{get\+Im\+Right@{get\+Im\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Im\+Right()}{getImRight()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Im\+Right (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the right (second) image. 

\begin{DoxyReturn}{Returns}
the right (second) image. 
\end{DoxyReturn}


Definition at line 528 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
528                                           \{
529     \textcolor{keywordflow}{return} this->imright;
530 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a19009c20003a5c7e957a4b3c34913fe9}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Right\+Und@{get\+Im\+Right\+Und}}
\index{get\+Im\+Right\+Und@{get\+Im\+Right\+Und}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Im\+Right\+Und()}{getImRightUnd()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Im\+Right\+Und (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the right undistorted image. 

\begin{DoxyReturn}{Returns}
the right undistorted image. 
\end{DoxyReturn}


Definition at line 1500 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1500                                              \{
1501     \textcolor{keywordflow}{return} this->imrightund;
1502 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a932e0ebd63c3e9a93b33c1846459aadc}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Kleft@{get\+Kleft}}
\index{get\+Kleft@{get\+Kleft}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Kleft()}{getKleft()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Kleft (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the 3x3 left camera matrix. 

\begin{DoxyReturn}{Returns}
3x3 left camera matrix. 
\end{DoxyReturn}


Definition at line 96 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
96                                         \{
97     \textcolor{keywordflow}{return} this->Kleft;
98 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a6f9e53e949b77cd19e28a4ec92034a3d}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Kright@{get\+Kright}}
\index{get\+Kright@{get\+Kright}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Kright()}{getKright()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Kright (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the 3x3 right camera matrix. 

\begin{DoxyReturn}{Returns}
3x3 right camera matrix. 
\end{DoxyReturn}


Definition at line 101 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
101                                          \{
102     \textcolor{keywordflow}{return} this->Kright;
103 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ad81c9f7f4f15ef3f1e61d34fd8df9856}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+L\+Rectified@{get\+L\+Rectified}}
\index{get\+L\+Rectified@{get\+L\+Rectified}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+L\+Rectified()}{getLRectified()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+L\+Rectified (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



The method returns the first rectified image. 

\begin{DoxyReturn}{Returns}
The first rectified image. 
\end{DoxyReturn}


Definition at line 2161 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2162 \{
2163     \textcolor{keywordflow}{return} this->imgLeftRect;
2164 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ae1c7ef2cc1a3de5d10c6bb39fbb78719}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+MapperL@{get\+MapperL}}
\index{get\+MapperL@{get\+MapperL}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Mapper\+L()}{getMapperL()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+MapperL (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the mapping between the original left camera and the rectified left camera. 

\begin{DoxyReturn}{Returns}
a 16 bit signed 2 channel image containing the mapping from the original left camera to the rectified left camera. 
\end{DoxyReturn}


Definition at line 1915 of file stereo\+Camera.\+cpp.



Referenced by metric\+Triangulation().


\begin{DoxyCode}
1915                                           \{
1916     \textcolor{keywordflow}{return} this->MapperL;
1917 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ac3f7763fdb6ed57f96924bb0b32b4ea7}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+MapperR@{get\+MapperR}}
\index{get\+MapperR@{get\+MapperR}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Mapper\+R()}{getMapperR()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+MapperR (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the mapping between the original right camera and the rectified right camera. 

\begin{DoxyReturn}{Returns}
a 16 bit signed 2 channel image containing the mapping from the original right camera to the rectified right camera. 
\end{DoxyReturn}


Definition at line 1920 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1920                                           \{
1921     \textcolor{keywordflow}{return} this->MapperR;
1922 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_aa50cb648f92d099e1ffbb7bab57c3fc3}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Match\+Left@{get\+Match\+Left}}
\index{get\+Match\+Left@{get\+Match\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Match\+Left()}{getMatchLeft()}}
{\footnotesize\ttfamily const vector$<$ Point2f $>$ \& Stereo\+Camera\+::get\+Match\+Left (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the pixel coordinates of the matches in the left image. 

\begin{DoxyReturn}{Returns}
pixel coordinates of the matches in the left image. 
\end{DoxyReturn}


Definition at line 106 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
106                                                         \{
107     \textcolor{keywordflow}{return} this->InliersL;
108 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ac8b01bc577cc3de8e7e8bc246d5c50f0}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Match\+Right@{get\+Match\+Right}}
\index{get\+Match\+Right@{get\+Match\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Match\+Right()}{getMatchRight()}}
{\footnotesize\ttfamily const vector$<$ Point2f $>$ \& Stereo\+Camera\+::get\+Match\+Right (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the pixel coordinates of the matches in the right image. 

\begin{DoxyReturn}{Returns}
pixel coordinates of the matches in the right image. 
\end{DoxyReturn}


Definition at line 111 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
111                                                          \{
112     \textcolor{keywordflow}{return} this->InliersR;
113 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a9f10e66261a0211e5d786abc3df8a70b}} 
\index{Stereo\+Camera@{Stereo\+Camera}!getQ@{getQ}}
\index{getQ@{getQ}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Q()}{getQ()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::getQ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the 4x4 disparity-\/to-\/depth mapping matrix. 

\begin{DoxyReturn}{Returns}
4x4 disparity-\/to-\/depth mapping matrix. 
\end{DoxyReturn}


Definition at line 543 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
543                                     \{
544     \textcolor{keywordflow}{return} this->Q;
545 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ab3adb747963c617fd2fe1a919b0c59c7}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Lrect@{get\+R\+Lrect}}
\index{get\+R\+Lrect@{get\+R\+Lrect}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+R\+Lrect()}{getRLrect()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+R\+Lrect (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the rotation matrix between the original left camera and the rectified left camera. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the original left camera and the rectified left camera. 
\end{DoxyReturn}


Definition at line 1905 of file stereo\+Camera.\+cpp.



Referenced by compute\+World\+Image(), metric\+Triangulation(), and triangulate\+Known\+Disparity().


\begin{DoxyCode}
1905                                          \{
1906     \textcolor{keywordflow}{return} this->RLrect;
1907 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a08b520f9976fc3213047844fedc02a54}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Rotation@{get\+Rotation}}
\index{get\+Rotation@{get\+Rotation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Rotation()}{getRotation()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Rotation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the rotation matrix between the two cameras. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the first and the second camera. 
\end{DoxyReturn}


Definition at line 1596 of file stereo\+Camera.\+cpp.



Referenced by horn().


\begin{DoxyCode}
1596                                            \{
1597     \textcolor{keywordflow}{return} this->R;
1598 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_aff19b07a766c01d04ed623a05ef4d67d}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Rectified@{get\+R\+Rectified}}
\index{get\+R\+Rectified@{get\+R\+Rectified}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+R\+Rectified()}{getRRectified()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+R\+Rectified (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



The method returns the second rectified image. 

\begin{DoxyReturn}{Returns}
The second rectified image. 
\end{DoxyReturn}


Definition at line 2167 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2168 \{
2169     \textcolor{keywordflow}{return} this->imgRightRect;
2170 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a44e111911af89a299b134fd91b4bc7d6}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Rrect@{get\+R\+Rrect}}
\index{get\+R\+Rrect@{get\+R\+Rrect}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+R\+Rrect()}{getRRrect()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+R\+Rrect (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the rotation matrix between the original right camera and the rectified right camera. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the original right camera and the rectified right camera. 
\end{DoxyReturn}


Definition at line 1910 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1910                                          \{
1911     \textcolor{keywordflow}{return} this->RRrect;
1912 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a3ca6d46fc45835bff5fa0a5753ca40c0}} 
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Translation@{get\+Translation}}
\index{get\+Translation@{get\+Translation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{get\+Translation()}{getTranslation()}}
{\footnotesize\ttfamily const Mat \& Stereo\+Camera\+::get\+Translation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



It returns the translation vector between the two cameras. 

\begin{DoxyReturn}{Returns}
3x1 translation matrix between the first and the second camera. 
\end{DoxyReturn}


Definition at line 1591 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1591                                               \{
1592     \textcolor{keywordflow}{return} this->T;
1593 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_adf155975709fdbf09d3133899d074a02}} 
\index{Stereo\+Camera@{Stereo\+Camera}!horn@{horn}}
\index{horn@{horn}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{horn()}{horn()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::horn (\begin{DoxyParamCaption}\item[{Mat \&}]{K1,  }\item[{Mat \&}]{K2,  }\item[{vector$<$ Point2f $>$ \&}]{Points1,  }\item[{vector$<$ Point2f $>$ \&}]{Points2,  }\item[{Mat \&}]{Rot,  }\item[{Mat \&}]{Tras }\end{DoxyParamCaption})}



It performs the horn relative orientations algorithm i.\+e. 

it estimates the motion from one camera to another one using a initial guess. A good initial guess can be obtained using the essential\+Decomposition method. 
\begin{DoxyParams}{Parameters}
{\em K1} & 3x3 matrix with intrinsic parameters of the first camera \\
\hline
{\em K2} & 3x3 matrix with intrinsic parameters of the second camera \\
\hline
{\em Points1} & matches in the first image \\
\hline
{\em Points2} & matches in the second image \\
\hline
{\em Rot} & initial rotation (3x3 matrix) guess. The new output rotation is stored here \\
\hline
{\em Tras} & initial translation (3x1 matrix) guess. The new output translation is stored here \\
\hline
\end{DoxyParams}


Definition at line 1697 of file stereo\+Camera.\+cpp.



References get\+Rotation().



Referenced by horn\+Relative\+Orientations().


\begin{DoxyCode}
1697                                                                                                            
              \{
1698     \textcolor{keywordtype}{double} prevres = 1E40;
1699     \textcolor{keywordtype}{double} res = 1E39;
1700     \textcolor{keywordtype}{double} vanishing = 1E-16;
1701     Tras=Tras/norm(Tras);
1702 
1703     normalizePoints(K1,K2,PointsL,PointsR);
1704     \textcolor{keywordtype}{int} iters=0;
1705     Mat B(3,3,CV\_64FC1);
1706     Mat C(3,3,CV\_64FC1);
1707     Mat D(3,3,CV\_64FC1);
1708     Mat cs(3,1,CV\_64FC1);
1709     Mat ds(3,1,CV\_64FC1);
1710     Mat r1(3,1,CV\_64FC1);
1711     Mat r2(3,1,CV\_64FC1);
1712 
1713     \textcolor{keywordflow}{while} ( (prevres  - res  >  vanishing) ) \{
1714         iters = iters+1;
1715 
1716         B.setTo(0);
1717         C.setTo(0);
1718         D.setTo(0);
1719         cs.setTo(0);
1720         ds.setTo(0);
1721 
1722         prevres=res;
1723         res=0;
1724         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int) PointsL.size(); i++) \{
1725 
1726             r1.at<\textcolor{keywordtype}{double}>(0,0)=PointsL[i].x;
1727             r1.at<\textcolor{keywordtype}{double}>(1,0)=PointsL[i].y;
1728             r1.at<\textcolor{keywordtype}{double}>(2,0)=1;
1729             r1=r1/norm(r1);
1730 
1731             r2.at<\textcolor{keywordtype}{double}>(0,0)=PointsR[i].x;
1732             r2.at<\textcolor{keywordtype}{double}>(1,0)=PointsR[i].y;
1733             r2.at<\textcolor{keywordtype}{double}>(2,0)=1;
1734             r2=r2/norm(r2);
1735 
1736 
1737             Mat r1p= Rot*r1;
1738 
1739             Mat ci=r1p.cross(r2);
1740             Mat di=r1p.cross(r2.cross(Tras));
1741             Mat si=Tras.t()*ci;
1742 
1743 
1744             B=B+(ci*di.t());
1745             D=D+(di*di.t());
1746             C=C+(ci*ci.t());
1747 
1748             cs=cs+ (si.at<\textcolor{keywordtype}{double}>(0,0)*ci);
1749             ds=ds+ (si.at<\textcolor{keywordtype}{double}>(0,0)*di);
1750 
1751             Mat residual=Tras.t()*ci*ci.t()*Tras;
1752             res=res+residual.at<\textcolor{keywordtype}{double}>(0,0);
1753 
1754         \}
1755 
1756         Mat L(7,7,CV\_64FC1);
1757         L.setTo(0);
1758 
1759         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1760             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++)
1761                 L.at<\textcolor{keywordtype}{double}>(i,j)=C.at<\textcolor{keywordtype}{double}>(i,j);
1762 
1763         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1764             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1765                 L.at<\textcolor{keywordtype}{double}>(i,j)=B.at<\textcolor{keywordtype}{double}>(i,j-3);
1766 
1767         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1768             L.at<\textcolor{keywordtype}{double}>(i,6)=Tras.at<\textcolor{keywordtype}{double}>(i,0);
1769 
1770 
1771         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=3; i<6; i++)
1772             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++) \{
1773                 Mat Bt=B.t();
1774                 L.at<\textcolor{keywordtype}{double}>(i,j)=Bt.at<\textcolor{keywordtype}{double}>(i-3,j);
1775 
1776             \}
1777 
1778 
1779         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=3; i<6; i++)
1780             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1781                 L.at<\textcolor{keywordtype}{double}>(i,j)=D.at<\textcolor{keywordtype}{double}>(i-3,j-3);
1782 
1783         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++) \{
1784             Mat Trast=Tras.t();
1785             L.at<\textcolor{keywordtype}{double}>(6,j)=Trast.at<\textcolor{keywordtype}{double}>(0,j);
1786         \}
1787 
1788 
1789         Mat Y(7,1,CV\_64FC1);
1790         Y.setTo(0);
1791 
1792         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++)
1793             Y.at<\textcolor{keywordtype}{double}>(j,0)=-cs.at<\textcolor{keywordtype}{double}>(j,0);
1794 
1795         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1796             Y.at<\textcolor{keywordtype}{double}>(j,0)=-ds.at<\textcolor{keywordtype}{double}>(j-3,0);
1797 
1798         Mat Linv=L.inv();
1799         Mat result=Linv*Y;
1800         Tras=Tras+result(Range(0,3),Range(0,1));
1801         Tras=Tras/norm(Tras);
1802 
1803         Mat q(4,1,CV\_64FC1);
1804 
1805         Mat temp=result(Range(3,6),Range(0,1));
1806         q.at<\textcolor{keywordtype}{double}>(0,0)= sqrt(1-(0.25* norm(temp)*norm(temp)));
1807         q.at<\textcolor{keywordtype}{double}>(1,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(3,0);
1808         q.at<\textcolor{keywordtype}{double}>(2,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(4,0);
1809         q.at<\textcolor{keywordtype}{double}>(3,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(5,0);
1810 
1811 
1812         Mat deltaR(3,3,CV\_64FC1);
1813         getRotation(q,deltaR);
1814 
1815         Rot=deltaR*Rot;
1816 
1817         SVD dec(Rot);
1818 
1819         Mat Id = Mat::eye(3, 3, CV\_64F);
1820 
1821         Mat Vt=dec.vt;
1822         Mat U=dec.u;
1823 
1824         Rot=U*Id*Vt;
1825     \}
1826 
1827 
1828 
1829 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a36dae897d07544e8faca8c90216173a6}} 
\index{Stereo\+Camera@{Stereo\+Camera}!horn\+Relative\+Orientations@{horn\+Relative\+Orientations}}
\index{horn\+Relative\+Orientations@{horn\+Relative\+Orientations}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{horn\+Relative\+Orientations()}{hornRelativeOrientations()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::horn\+Relative\+Orientations (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



It performs the horn relative orientations, all the parameters are assumed initialized in the \hyperlink{classStereoCamera}{Stereo\+Camera} object. 

The new output Rotation and Translation matrices are stored in the R and T members. 

Definition at line 1635 of file stereo\+Camera.\+cpp.



References horn().


\begin{DoxyCode}
1635                                             \{
1636 
1637     \textcolor{keywordflow}{if}(this->PointsL.size()<10 || this->PointsR.size()<10) \{
1638         cout << \textcolor{stringliteral}{"No matches found! Run findMatch fist!"} << endl;
1639         \textcolor{keywordflow}{return};
1640     \}
1641 
1642 
1643     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->Kright.empty() || this->R.empty() || this->T.empty()) \{
1644         cout << \textcolor{stringliteral}{"Cameras are empty, run Calibration first"} << endl;
1645         \textcolor{keywordflow}{return};
1646     \}
1647 
1648     \textcolor{keywordflow}{if}(InliersL.empty()) \{
1649         InliersL=PointsL;
1650         InliersR=PointsR;
1651     \}
1652 
1653     Mat Rot=this->R.clone();
1654     Mat Tras=this->T.clone();
1655     horn(this->Kleft,this->Kright,this->InliersL,this->InliersR,Rot,Tras);
1656 
1657 
1658     this->R=Rot.clone();
1659     this->Rinit=Rot.clone();
1660 
1661     this->T=Tras/norm(Tras)*norm(T);
1662     this->Tinit=Tras/norm(Tras)*norm(Tinit);
1663 
1664     this->updatePMatrix();
1665 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a067e1e94a48cb390491fea0f6748dda8}} 
\index{Stereo\+Camera@{Stereo\+Camera}!init\+E\+L\+AS@{init\+E\+L\+AS}}
\index{init\+E\+L\+AS@{init\+E\+L\+AS}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{init\+E\+L\+A\+S()}{initELAS()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::init\+E\+L\+AS (\begin{DoxyParamCaption}\item[{yarp\+::os\+::\+Resource\+Finder \&}]{rf }\end{DoxyParamCaption})}



Initialization of E\+L\+AS parameters. 


\begin{DoxyParams}{Parameters}
{\em rf} & The Resource\+Finder mechanism is used to set the parameters either to the default value or to the value passed by the user via command line. See the documentation of the \hyperlink{group__SFM}{S\+FM} module to get the list of parameters that are processed by this initialization function. \\
\hline
\end{DoxyParams}


Definition at line 164 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
165 \{
166     use\_elas = \textcolor{keyword}{true};
167 
168     \textcolor{keywordtype}{string} elas\_string = rf.check(\textcolor{stringliteral}{"elas\_setting"},Value(\textcolor{stringliteral}{"ROBOTICS"})).asString();
169 
170     \textcolor{keywordtype}{double} disp\_scaling\_factor = rf.check(\textcolor{stringliteral}{"disp\_scaling\_factor"},Value(1.0)).asDouble();
171 
172     elaswrap = \textcolor{keyword}{new} elasWrapper(disp\_scaling\_factor, elas\_string);
173 
174 
175     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_subsampling"}))
176         elaswrap->set\_subsampling(\textcolor{keyword}{true});
177 
178     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_add\_corners"}))
179         elaswrap->set\_add\_corners(\textcolor{keyword}{true});
180 
181 
182     elaswrap->set\_ipol\_gap\_width(40);
183     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_ipol\_gap\_width"}))
184         elaswrap->set\_ipol\_gap\_width(rf.find(\textcolor{stringliteral}{"elas\_ipol\_gap\_width"}).asInt());
185 
186 
187     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_support\_threshold"}))
188         elaswrap->set\_support\_threshold(rf.find(\textcolor{stringliteral}{"elas\_support\_threshold"}).asDouble());
189 
190     \textcolor{keywordflow}{if}(rf.check(\textcolor{stringliteral}{"elas\_gamma"}))
191         elaswrap->set\_gamma(rf.find(\textcolor{stringliteral}{"elas\_gamma"}).asDouble());
192 
193     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_sradius"}))
194         elaswrap->set\_sradius(rf.find(\textcolor{stringliteral}{"elas\_sradius"}).asDouble());
195 
196     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_match\_texture"}))
197         elaswrap->set\_match\_texture(rf.find(\textcolor{stringliteral}{"elas\_match\_texture"}).asInt());
198 
199     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_filter\_median"}))
200         elaswrap->set\_filter\_median(rf.find(\textcolor{stringliteral}{"elas\_filter\_median"}).asBool());
201 
202     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_filter\_adaptive\_mean"}))
203         elaswrap->set\_filter\_adaptive\_mean(rf.find(\textcolor{stringliteral}{"elas\_filter\_adaptive\_mean"}).asBool());
204 
205     cout << endl << \textcolor{stringliteral}{"ELAS parameters:"} << endl << endl;
206 
207     cout << \textcolor{stringliteral}{"disp\_scaling\_factor: "} << disp\_scaling\_factor << endl;
208 
209     cout << \textcolor{stringliteral}{"setting: "} << elas\_string << endl;
210 
211     cout << \textcolor{stringliteral}{"postprocess\_only\_left: "} << elaswrap->get\_postprocess\_only\_left() << endl;
212     cout << \textcolor{stringliteral}{"subsampling: "} << elaswrap->get\_subsampling() << endl;
213 
214     cout << \textcolor{stringliteral}{"add\_corners: "} << elaswrap->get\_add\_corners() << endl;
215 
216     cout << \textcolor{stringliteral}{"ipol\_gap\_width: "} << elaswrap->get\_ipol\_gap\_width() << endl;
217 
218     cout << \textcolor{stringliteral}{"support\_threshold: "} << elaswrap->get\_support\_threshold() << endl;
219     cout << \textcolor{stringliteral}{"gamma: "} << elaswrap->get\_gamma() << endl;
220     cout << \textcolor{stringliteral}{"sradius: "} << elaswrap->get\_sradius() << endl;
221 
222     cout << \textcolor{stringliteral}{"match\_texture: "} << elaswrap->get\_match\_texture() << endl;
223 
224     cout << \textcolor{stringliteral}{"filter\_median: "} << elaswrap->get\_filter\_median() << endl;
225     cout << \textcolor{stringliteral}{"filter\_adaptive\_mean: "} << elaswrap->get\_filter\_adaptive\_mean() << endl;
226 
227     cout << endl;
228 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a2fcd3e1767bcf04716b0e2ac76098430}} 
\index{Stereo\+Camera@{Stereo\+Camera}!metric\+Triangulation@{metric\+Triangulation}}
\index{metric\+Triangulation@{metric\+Triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{metric\+Triangulation()}{metricTriangulation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Point3f Stereo\+Camera\+::metric\+Triangulation (\begin{DoxyParamCaption}\item[{Point2f \&}]{point1,  }\item[{double}]{th\+Meters = {\ttfamily 10} }\end{DoxyParamCaption})}



It performs the metric triangulation given the pixel coordinates on the first image. 

Run compute disparity before using this method. 
\begin{DoxyParams}{Parameters}
{\em point1} & the pixel coordinates in the first image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3D point w.\+r.\+t. the first camera reference system. 
\end{DoxyReturn}


Definition at line 1954 of file stereo\+Camera.\+cpp.



References get\+Disparity16(), and get\+Mapper\+L().


\begin{DoxyCode}
1954                                                                           \{
1955     lock\_guard<mutex> lg(mtx);
1956 
1957     \textcolor{keywordflow}{if}(Q.empty() || Disparity16.empty()) \{
1958         cout << \textcolor{stringliteral}{"Run computeDisparity() method first!"} << endl;
1959         Point3f point;
1960         point.x=0.0;
1961         point.y=0.0;
1962         point.z=0.0;
1963         \textcolor{keywordflow}{return} point;
1964     \}
1965 
1966     \textcolor{keywordtype}{int} u=(int) point1.x;
1967     \textcolor{keywordtype}{int} v=(\textcolor{keywordtype}{int}) point1.y;
1968     Point3f point;
1969 
1970     \textcolor{comment}{// Mapping from Rectified Cameras to Original Cameras}
1971     Mat Mapper=this->getMapperL();
1972 
1973     \textcolor{keywordflow}{if}(Mapper.empty()) \{
1974         point.x=0.0;
1975         point.y=0.0;
1976         point.z=0.0;
1977         \textcolor{keywordflow}{return} point;
1978     \}
1979 
1980     \textcolor{keywordtype}{float} usign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u];
1981     \textcolor{keywordtype}{float} vsign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u+1];
1982 
1983     u=cvRound(usign);
1984     v=cvRound(vsign);
1985 
1986     \textcolor{keyword}{const} cv::Mat& disp16=this->getDisparity16();
1987 
1988     \textcolor{keywordflow}{if}(u<0 || u>=disp16.size().width || v<0 || v>=disp16.size().height) \{
1989         point.x=0.0;
1990         point.y=0.0;
1991         point.z=0.0;
1992         \textcolor{keywordflow}{return} point;
1993     \}
1994 
1995     CvScalar scal=cvGet2D(&disp16,v,u);
1996     \textcolor{keywordtype}{double} disparity=scal.val[0]/16.0;
1997     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) disparity*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
1998     point.x= (float)((\textcolor{keywordtype}{float}) (usign+1)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
1999     point.y=(float)((\textcolor{keywordtype}{float}) (vsign+1)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
2000     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
2001 
2002     point.x=point.x/w;
2003     point.y=point.y/w;
2004     point.z=point.z/w;
2005 
2006     \textcolor{comment}{// discard points far more than thMeters meters or with not valid disparity (<0)}
2007     \textcolor{keywordflow}{if}(point.z>thMeters || point.z<0) \{
2008         point.x=0.0;
2009         point.y=0.0;
2010         point.z=0.0;
2011     \}
2012     \textcolor{keywordflow}{else} \{
2013         Mat P(3,1,CV\_64FC1);
2014         P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2015         P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2016         P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2017 
2018         \textcolor{comment}{// Rototranslation from rectified camera to original camera}
2019         P=this->getRLrect().t()*P;
2020 
2021         point.x=(float) P.at<\textcolor{keywordtype}{double}>(0,0);
2022         point.y=(float) P.at<\textcolor{keywordtype}{double}>(1,0);
2023         point.z=(float) P.at<\textcolor{keywordtype}{double}>(2,0);
2024     \}
2025 
2026     \textcolor{keywordflow}{return} point;
2027 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a3cf53fac6336eea107a26bd5cdbbdd03}} 
\index{Stereo\+Camera@{Stereo\+Camera}!metric\+Triangulation@{metric\+Triangulation}}
\index{metric\+Triangulation@{metric\+Triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{metric\+Triangulation()}{metricTriangulation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Point3f Stereo\+Camera\+::metric\+Triangulation (\begin{DoxyParamCaption}\item[{Point2f \&}]{point1,  }\item[{Mat \&}]{H,  }\item[{double}]{th\+Meters = {\ttfamily 10} }\end{DoxyParamCaption})}



It performs the metric triangulation given the pixel coordinates on the first image. 

The 3D Point is w.\+r.\+t the system defined by the parameter H. Run compute disparity before using this method. 
\begin{DoxyParams}{Parameters}
{\em point1} & the pixel coordinates in the first image. \\
\hline
{\em H} & the 4x4 rototranslation matrix of the system. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3D point w.\+r.\+t. the reference system defined by H. 
\end{DoxyReturn}


Definition at line 2030 of file stereo\+Camera.\+cpp.



References get\+Disparity16(), get\+Mapper\+L(), and get\+R\+Lrect().


\begin{DoxyCode}
2030                                                                                   \{
2031     lock\_guard<mutex> lg(mtx);
2032 
2033     \textcolor{keywordflow}{if}(H.empty())
2034         H=H.eye(4,4,CV\_64FC1);
2035 
2036     \textcolor{keywordflow}{if}(Q.empty() || Disparity16.empty()) \{
2037         cout << \textcolor{stringliteral}{"Run computeDisparity() method first!"} << endl;
2038         Point3f point;
2039         point.x=0.0;
2040         point.y=0.0;
2041         point.z=0.0;
2042         \textcolor{keywordflow}{return} point;
2043     \}
2044 
2045     \textcolor{keywordtype}{int} u=(int) point1.x; \textcolor{comment}{// matrix starts from (0,0), pixels from (1,1)}
2046     \textcolor{keywordtype}{int} v=(\textcolor{keywordtype}{int}) point1.y;
2047     Point3f point;
2048 
2049 
2050     \textcolor{comment}{// Mapping from Rectified Cameras to Original Cameras}
2051     Mat Mapper=this->getMapperL();
2052 
2053     \textcolor{keywordflow}{if}(Mapper.empty()) \{
2054         point.x=0.0;
2055         point.y=0.0;
2056         point.z=0.0;
2057         \textcolor{keywordflow}{return} point;
2058     \}
2059 
2060     \textcolor{keywordtype}{float} usign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u];
2061     \textcolor{keywordtype}{float} vsign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u+1];
2062 
2063     u=cvRound(usign);
2064     v=cvRound(vsign);
2065 
2066     \textcolor{keyword}{const} cv::Mat& disp16=this->getDisparity16();
2067 
2068     \textcolor{keywordflow}{if}(u<0 || u>=disp16.size().width || v<0 || v>=disp16.size().height) \{
2069         point.x=0.0;
2070         point.y=0.0;
2071         point.z=0.0;
2072         \textcolor{keywordflow}{return} point;
2073     \}
2074 
2075     CvScalar scal=cvGet2D(&disp16,v,u);
2076     \textcolor{keywordtype}{double} disparity=scal.val[0]/16.0;
2077     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) disparity*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
2078     point.x= (float)((\textcolor{keywordtype}{float}) (usign+1)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
2079     point.y=(float)((\textcolor{keywordtype}{float}) (vsign+1)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
2080     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
2081 
2082     point.x=point.x/w;
2083     point.y=point.y/w;
2084     point.z=point.z/w;
2085 
2086     \textcolor{comment}{// discard points far more than thMeters meters or with not valid disparity (<0)}
2087     \textcolor{keywordflow}{if}(point.z>thMeters || point.z<0) \{
2088         point.x=0.0;
2089         point.y=0.0;
2090         point.z=0.0;
2091         \textcolor{keywordflow}{return} point;
2092     \}
2093 
2094     Mat RLrectTmp=this->getRLrect().t();
2095     Mat Tfake = Mat::zeros(0,3,CV\_64F);
2096     Mat P(4,1,CV\_64FC1);
2097     P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2098     P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2099     P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2100     P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2101 
2102     Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2103     P=H*Hrect*P;
2104 
2105     point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2106     point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2107     point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2108 
2109     \textcolor{keywordflow}{return} point;
2110 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a03406c9d31c1b765a8d6ef9641222309}} 
\index{Stereo\+Camera@{Stereo\+Camera}!project\+Points3D@{project\+Points3D}}
\index{project\+Points3D@{project\+Points3D}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{project\+Points3\+D()}{projectPoints3D()}}
{\footnotesize\ttfamily vector$<$ Point2f $>$ Stereo\+Camera\+::project\+Points3D (\begin{DoxyParamCaption}\item[{string}]{camera,  }\item[{vector$<$ Point3f $>$ \&}]{points3D,  }\item[{Mat \&}]{H }\end{DoxyParamCaption})}



The method returns the 2D projection of a set of 3D points in the cartesian space to the specified camera. 


\begin{DoxyParams}{Parameters}
{\em camera} & \char`\"{}left\char`\"{} or \char`\"{}right\char`\"{} camera \\
\hline
{\em point3D} & the list of the 3D position in the reference frame H \\
\hline
{\em H} & the transformation from the camera reference system to the H reference system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 2D positions. 
\end{DoxyReturn}


Definition at line 2173 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2174 \{
2175     vector<Point2f> points2D;
2176 
2177     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
2178         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
2179         \textcolor{keywordflow}{return} points2D;
2180     \}
2181 
2182     \textcolor{keywordflow}{if}(H.empty())
2183         H=H.eye(4,4,CV\_64FC1);
2184 
2185     lock\_guard<mutex> lg(mtx);
2186     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<points3D.size(); i++)
2187     \{
2188         \textcolor{comment}{// Apply inverse Trasformation for each point}
2189         Point3f point=points3D[i];
2190         Mat P(4,1,CV\_64FC1);
2191         P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2192         P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2193         P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2194         P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2195 
2196         P=H.inv()*P;
2197 
2198         point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2199         point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2200         point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2201 
2202         points3D[i]=point;
2203     \}
2204 
2205     Mat cameraMatrix, distCoeff, rvec, tvec;
2206     rvec=Mat::zeros(3,1,CV\_64FC1);
2207 
2208     \textcolor{keywordflow}{if}(camera==\textcolor{stringliteral}{"left"})
2209     \{
2210         cameraMatrix=this->Kleft;
2211         distCoeff=this->DistL;
2212         Mat R2= Mat::eye(3,3,CV\_64FC1);
2213         Rodrigues(R2,rvec);
2214         tvec=Mat::zeros(3,1,CV\_64FC1);
2215     \}
2216     \textcolor{keywordflow}{else}
2217     \{
2218         cameraMatrix=this->Kright;
2219         distCoeff=this->DistR;
2220         Mat R2= this->R;
2221         Rodrigues(R2,rvec);
2222         tvec=this->T;
2223     \}
2224 
2225     Mat points3Mat(points3D);
2226     projectPoints(points3Mat,rvec,tvec,cameraMatrix,distCoeff,points2D);
2227     \textcolor{keywordflow}{return} points2D;
2228 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ae5ac866c6d4b6c4819b01a918e7b61e0}} 
\index{Stereo\+Camera@{Stereo\+Camera}!rectify\+Images@{rectify\+Images}}
\index{rectify\+Images@{rectify\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{rectify\+Images()}{rectifyImages()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::rectify\+Images (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



The method rectifies the two images\+: it transform each image plane such that pairs conjugate epipolar lines become collinear and parallel to one of the image axes (i.\+e. 

there is 0 disparity on the Y axis). 

Definition at line 548 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
549 \{
550     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
551         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
552         \textcolor{keywordflow}{return};
553     \}
554     \textcolor{keywordflow}{if}(this->imleft.empty() || this->imright.empty()) \{
555         cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
556         \textcolor{keywordflow}{return};
557     \}
558 
559     Size img\_size = this->imleft.size();
560 
561     \textcolor{keywordflow}{if}(cameraChanged)
562     \{
563         lock\_guard<mutex> lg(mtx);
564         stereoRectify(this->Kleft, this->DistL, this->Kright, this->DistR, img\_size, this->R, this->T, 
      this->RLrect, this->RRrect, this->PLrect, this->PRrect, this->Q, -1);
565     \}
566 
567     \textcolor{keywordflow}{if}(cameraChanged)
568     \{
569         initUndistortRectifyMap(this->Kleft, this->DistL, this->RLrect, this->PLrect, img\_size, CV\_32FC1, 
      this->map11, this->map12);
570         initUndistortRectifyMap(this->Kright,  this->DistR, this->RRrect, this->PRrect, img\_size, CV\_32FC1,
       this->map21, this->map22);
571     \}
572 
573     remap(this->imleft, this->imgLeftRect, this->map11, this->map12, cv::INTER\_LINEAR);
574     remap(this->imright, this->imgRightRect, this->map21,this->map22, cv::INTER\_LINEAR);
575 
576     cameraChanged = \textcolor{keyword}{false};
577 
578 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ac92ce0b90b69773284be5825b0199bda}} 
\index{Stereo\+Camera@{Stereo\+Camera}!remap\+Disparity@{remap\+Disparity}}
\index{remap\+Disparity@{remap\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{remap\+Disparity()}{remapDisparity()}}
{\footnotesize\ttfamily cv\+::\+Mat Stereo\+Camera\+::remap\+Disparity (\begin{DoxyParamCaption}\item[{cv\+::\+Mat}]{disp }\end{DoxyParamCaption})}



Remaps the disparity map on the basis of the mapping previously computed. 


\begin{DoxyParams}{Parameters}
{\em disp} & the disparity map to be remapped \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the remapped disparity map 
\end{DoxyReturn}


Definition at line 2423 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2424 \{
2425 
2426     cv::Mat remapped;
2427 
2428     Mat x;
2429     remap(disp,remapped,this->MapperL,x,cv::INTER\_LINEAR);
2430     remapped.convertTo(remapped,CV\_8U);
2431 
2432     \textcolor{keywordflow}{return} remapped;
2433 
2434 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a9f06cd4b170ad0ba45b681ee93d64851}} 
\index{Stereo\+Camera@{Stereo\+Camera}!save\+Calibration@{save\+Calibration}}
\index{save\+Calibration@{save\+Calibration}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{save\+Calibration()}{saveCalibration()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::save\+Calibration (\begin{DoxyParamCaption}\item[{string}]{extrinsic\+File\+Path,  }\item[{string}]{intrinsic\+File\+Path }\end{DoxyParamCaption})}



It saves the calibration. 


\begin{DoxyParams}{Parameters}
{\em extrinsic\+File\+Path} & the path of the extrinsic parameters file \\
\hline
{\em intrinsic\+File\+Path} & the path of the intrinsic parameters file \\
\hline
\end{DoxyParams}


Definition at line 470 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
470                                                                                      \{
471 
472     \textcolor{keywordflow}{if}( Kleft.empty() || Kright.empty() || DistL.empty() || DistR.empty() || R.empty() || T.empty()) \{
473         std::cout << \textcolor{stringliteral}{"Error: cameras are not calibrated! Run the calibration or set intrinsic and extrinsic
       parameters"} << std::endl;
474         \textcolor{keywordflow}{return};
475     \}
476 
477     FileStorage fs(intrinsicFilePath+\textcolor{stringliteral}{".yml"}, FileStorage::WRITE);
478     \textcolor{keywordflow}{if}( fs.isOpened() )
479     \{
480         fs << \textcolor{stringliteral}{"M1"} << Kleft << \textcolor{stringliteral}{"D1"} << DistL << \textcolor{stringliteral}{"M2"} << Kright << \textcolor{stringliteral}{"D2"} << DistR;
481         fs.release();
482     \}
483     \textcolor{keywordflow}{else}
484         cout << \textcolor{stringliteral}{"Error: can not save the intrinsic parameters\(\backslash\)n"};
485 
486     fs.open(extrinsicFilePath+\textcolor{stringliteral}{".yml"}, FileStorage::WRITE);
487     \textcolor{keywordflow}{if}( fs.isOpened() )
488     \{
489         fs << \textcolor{stringliteral}{"R"} << R << \textcolor{stringliteral}{"T"} << T <<\textcolor{stringliteral}{"Q"} << Q;
490         fs.release();
491     \}
492     \textcolor{keywordflow}{else}
493         std::cout << \textcolor{stringliteral}{"Error: can not save the intrinsic parameters"} << std::endl;
494 
495     ofstream fout((intrinsicFilePath+\textcolor{stringliteral}{".ini"}).c\_str());
496 
497     \textcolor{comment}{// Left Eye}
498     fout << \textcolor{stringliteral}{"[left]"} << endl;
499     fout << \textcolor{stringliteral}{"fx "} << Kleft.at<\textcolor{keywordtype}{double}>(0,0) << endl;
500     fout << \textcolor{stringliteral}{"fy "} << Kleft.at<\textcolor{keywordtype}{double}>(1,1) << endl;
501     fout << \textcolor{stringliteral}{"cx "} << Kleft.at<\textcolor{keywordtype}{double}>(0,2) << endl;
502     fout << \textcolor{stringliteral}{"cy "} << Kleft.at<\textcolor{keywordtype}{double}>(1,2) << endl;
503     fout << \textcolor{stringliteral}{"k1 "} << DistL.at<\textcolor{keywordtype}{double}>(0,0) << endl;
504     fout << \textcolor{stringliteral}{"k2 "} << DistL.at<\textcolor{keywordtype}{double}>(1,0) << endl;
505     fout << \textcolor{stringliteral}{"p1 "} << DistL.at<\textcolor{keywordtype}{double}>(2,0) << endl;
506     fout << \textcolor{stringliteral}{"p2 "} << DistL.at<\textcolor{keywordtype}{double}>(3,0) << endl;
507 
508     \textcolor{comment}{// Right Eye}
509     fout << \textcolor{stringliteral}{"[right]"} << endl;
510     fout << \textcolor{stringliteral}{"fx "} << Kright.at<\textcolor{keywordtype}{double}>(0,0) << endl;
511     fout << \textcolor{stringliteral}{"fy "} << Kright.at<\textcolor{keywordtype}{double}>(1,1) << endl;
512     fout << \textcolor{stringliteral}{"cx "} << Kright.at<\textcolor{keywordtype}{double}>(0,2) << endl;
513     fout << \textcolor{stringliteral}{"cy "} << Kright.at<\textcolor{keywordtype}{double}>(1,2) << endl;
514     fout << \textcolor{stringliteral}{"k1 "} << DistR.at<\textcolor{keywordtype}{double}>(0,0) << endl;
515     fout << \textcolor{stringliteral}{"k2 "} << DistR.at<\textcolor{keywordtype}{double}>(1,0) << endl;
516     fout << \textcolor{stringliteral}{"p1 "} << DistR.at<\textcolor{keywordtype}{double}>(2,0) << endl;
517     fout << \textcolor{stringliteral}{"p2 "} << DistR.at<\textcolor{keywordtype}{double}>(3,0) << endl;
518 
519     fout.close();
520 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a9ecb303d7b36eaf5f086d8ddebd29b95}} 
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Expected\+Position@{set\+Expected\+Position}}
\index{set\+Expected\+Position@{set\+Expected\+Position}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{set\+Expected\+Position()}{setExpectedPosition()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::set\+Expected\+Position (\begin{DoxyParamCaption}\item[{Mat \&}]{Rot,  }\item[{Mat \&}]{Tran }\end{DoxyParamCaption})}



The function set the expected Rotation and Translation parameters for the current image pair. 

They can be computed using the Kinematics. 
\begin{DoxyParams}{Parameters}
{\em Rot} & 3x3 matrix representing the rotation between the left and the right camera. \\
\hline
{\em Tran} & 3x1 vector representing the translation between the left and the right camera. \\
\hline
\end{DoxyParams}


Definition at line 2416 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2417 \{
2418     R\_exp=Rot;
2419     T\_exp=Tran;
2420 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_adc36a2585c583219bddbb1c7fb0725df}} 
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Images@{set\+Images}}
\index{set\+Images@{set\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{set\+Images()}{setImages()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::set\+Images (\begin{DoxyParamCaption}\item[{const Mat \&}]{first\+Img,  }\item[{const Mat \&}]{second\+Img }\end{DoxyParamCaption})}



It stores in memory a couple of images. 


\begin{DoxyParams}{Parameters}
{\em first\+Img} & the images acquired from the first (main) camera \\
\hline
{\em second\+Img} & the images acquired from the second (secondary) camera \\
\hline
\end{DoxyParams}


Definition at line 231 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
231                                                               \{
232     this->imleft=left;
233     this->imright=right;
234 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a54754623497c8dddb61f520e17f465f8}} 
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Intrinsics@{set\+Intrinsics}}
\index{set\+Intrinsics@{set\+Intrinsics}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{set\+Intrinsics()}{setIntrinsics()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::set\+Intrinsics (\begin{DoxyParamCaption}\item[{Mat \&}]{K1,  }\item[{Mat \&}]{K2,  }\item[{Mat \&}]{Dist1,  }\item[{Mat \&}]{Dist2 }\end{DoxyParamCaption})}



It sets the intrinsic parameters. 


\begin{DoxyParams}{Parameters}
{\em K1} & 3x3 camera matrix of the first camera. \\
\hline
{\em K2} & 3x3 camera matrix of the second camera. \\
\hline
{\em Dist1} & 4x1 distortion coefficients vector of the first camera. \\
\hline
{\em Dist2} & 4x1 distortion coefficients vector of the second camera. \\
\hline
\end{DoxyParams}


Definition at line 1940 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1940                                                                          \{
1941     lock\_guard<mutex> lg(mtx);
1942     this->Kleft=KL;
1943     this->Kright=KR;
1944     this->DistL=DistL;
1945     this->DistR=DistR;
1946 
1947     \textcolor{keywordflow}{if}(!this->R.empty() && !this->T.empty())
1948         updatePMatrix();
1949     this->cameraChanged=\textcolor{keyword}{true};
1950     buildUndistortRemap();
1951 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ae683fafa11ea73e4b4c278402be259b6}} 
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Matches@{set\+Matches}}
\index{set\+Matches@{set\+Matches}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{set\+Matches()}{setMatches()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::set\+Matches (\begin{DoxyParamCaption}\item[{std\+::vector$<$ cv\+::\+Point2f $>$ \&}]{pointsL,  }\item[{std\+::vector$<$ cv\+::\+Point2f $>$ \&}]{pointsR }\end{DoxyParamCaption})}



The function initialize the matches of the current image pair. 

For example matches can be computed in G\+PU with higher framerate. 
\begin{DoxyParams}{Parameters}
{\em pointsL} & vector of Point2f representing the keypoints on the left image. \\
\hline
{\em pointsR} & vector of Point2f representing the keypoints on the right image. \\
\hline
\end{DoxyParams}


Definition at line 2408 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2409 \{
2410     PointsL=pointsL;
2411     PointsR=pointsR;
2412 
2413 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a1329b3894d527e1505618f57a1304624}} 
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Rotation@{set\+Rotation}}
\index{set\+Rotation@{set\+Rotation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{set\+Rotation()}{setRotation()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::set\+Rotation (\begin{DoxyParamCaption}\item[{Mat \&}]{Rot,  }\item[{int}]{mode = {\ttfamily 0} }\end{DoxyParamCaption})}



It sets the rotation matrix (if known) between the first and the second camera. 


\begin{DoxyParams}{Parameters}
{\em Rot} & the 3x3 rotation matrix. \\
\hline
{\em mode} & the following values are allowed\+: {\bfseries mode=0} the rotation matrix R is set equal to Rot. {\bfseries mode=1} the rotation matrix R is set equal to Rot$\ast$R. {\bfseries mode=2} the rotation matrix R is set equal to Rot$\ast$\+Rinit. \\
\hline
\end{DoxyParams}


Definition at line 1505 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1505                                                 \{
1506     lock\_guard<mutex> lg(mtx);
1507     \textcolor{keywordflow}{if}(mul==0)
1508         this->R=Rot;
1509     \textcolor{keywordflow}{if}(mul==1)
1510         this->R=Rot*R;
1511     \textcolor{keywordflow}{if}(mul==2)
1512         this->R=Rot*Rinit;
1513 
1514     \textcolor{keywordflow}{if}(R\_exp.empty())
1515         R\_exp=R;
1516     this->updatePMatrix();
1517     this->cameraChanged=\textcolor{keyword}{true};
1518 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a7b10f1218e8e70f47b22080ba1820d39}} 
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Translation@{set\+Translation}}
\index{set\+Translation@{set\+Translation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{set\+Translation()}{setTranslation()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::set\+Translation (\begin{DoxyParamCaption}\item[{Mat \&}]{Tras,  }\item[{int}]{mul = {\ttfamily 0} }\end{DoxyParamCaption})}



It sets the translation vector (if known) between the first and the second camera. 


\begin{DoxyParams}{Parameters}
{\em Tras} & the 3x1 translation matrix. \\
\hline
{\em mode} & the following values are allowed\+: {\bfseries mode=0} the translation vector T is set equal to Tras. {\bfseries mode=1} the translation vector T is set equal to Tras+T. {\bfseries mode=2} the translation vector T is set equal to Tras+\+Tinit. \\
\hline
\end{DoxyParams}


Definition at line 1521 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1521                                                     \{
1522     lock\_guard<mutex> lg(mtx);
1523     \textcolor{keywordflow}{if}(mul==0)
1524         this->T=Tras;
1525     \textcolor{keywordflow}{if}(mul==1)
1526         this->T=Tras+T;
1527     \textcolor{keywordflow}{if}(mul==2)
1528         this->T=Tras+Tinit;
1529 
1530     \textcolor{keywordflow}{if}(T\_exp.empty())
1531         T\_exp=T;
1532 
1533     \textcolor{keywordflow}{if}(!this->Kleft.empty() && !this->Kright.empty())
1534         this->updatePMatrix();
1535     this->cameraChanged=\textcolor{keyword}{true};
1536 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a398f45eeefe7979a834659cfbb7a6961}} 
\index{Stereo\+Camera@{Stereo\+Camera}!stereo\+Calibration@{stereo\+Calibration}}
\index{stereo\+Calibration@{stereo\+Calibration}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{stereo\+Calibration()}{stereoCalibration()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::stereo\+Calibration (\begin{DoxyParamCaption}\item[{vector$<$ string $>$}]{image\+List,  }\item[{int}]{board\+Width,  }\item[{int}]{board\+Height,  }\item[{float}]{sqsize = {\ttfamily 1.0} }\end{DoxyParamCaption})}



It performs the stereo camera calibration. 

(see stereo\+Calibration module) 
\begin{DoxyParams}{Parameters}
{\em image\+List} & is the list containing the paths of the images with the chessboard patterns. even indices refer to Left camera images (i.\+e. main camera images), while odd indices refer to Right camera images. \\
\hline
{\em board\+Width} & the number of inner corners in the width direction of the chess board pattern (see stereo\+Calibration module) \\
\hline
{\em board\+Height} & the number of inner corners in the height direction of the chess board pattern (see stereo\+Calibration module) \\
\hline
{\em sqsize} & the size of the square of the chess board pattern. It is needed for a metric reconstruction. \\
\hline
\end{DoxyParams}


Definition at line 250 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
250                                                                                                            
      \{
251     Size boardSize;
252     boardSize.width=boardWidth;
253     boardSize.height=boardHeight;
254     runStereoCalib(imagelist, boardSize,sqsize);
255 
256 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a761ea623c4cde38b4fa1d798ef09b7ae}} 
\index{Stereo\+Camera@{Stereo\+Camera}!triangulate\+Known\+Disparity@{triangulate\+Known\+Disparity}}
\index{triangulate\+Known\+Disparity@{triangulate\+Known\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{triangulate\+Known\+Disparity()}{triangulateKnownDisparity()}}
{\footnotesize\ttfamily Point3f Stereo\+Camera\+::triangulate\+Known\+Disparity (\begin{DoxyParamCaption}\item[{float}]{u,  }\item[{float}]{v,  }\item[{float}]{d,  }\item[{Mat \&}]{H }\end{DoxyParamCaption})}



It performs the metric triangulation given the pixel coordinates on the first image and the disparity between the two R\+E\+C\+T\+I\+F\+I\+ED images. 

The 3D Point is w.\+r.\+t the system defined by the parameter H. 
\begin{DoxyParams}{Parameters}
{\em u} & the pixel x coordinate in the first image. \\
\hline
{\em v} & the pixel y coordinate in the first image. \\
\hline
{\em d} & the disparity on the x coordinate between the two rectified images. \\
\hline
{\em H} & the 4x4 rototranslation matrix of the system can be an empty matrix. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3D point w.\+r.\+t. the reference system defined by H. 
\end{DoxyReturn}


Definition at line 2113 of file stereo\+Camera.\+cpp.



References get\+R\+Lrect().


\begin{DoxyCode}
2114 \{
2115     lock\_guard<mutex> lg(mtx);
2116     \textcolor{keywordflow}{if}(Q.empty())
2117     \{
2118         cout << \textcolor{stringliteral}{"Run rectifyImages() method first!"} << endl;
2119         Point3f point;
2120         point.x=0.0;
2121         point.y=0.0;
2122         point.z=0.0;
2123         \textcolor{keywordflow}{return} point;
2124     \}
2125 
2126     \textcolor{keywordflow}{if}(H.empty())
2127         H=H.eye(4,4,CV\_64FC1);
2128 
2129     Point3f point;
2130 
2131     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) d*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
2132     point.x= (float)((\textcolor{keywordtype}{float}) (u)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
2133     point.y=(float)((\textcolor{keywordtype}{float}) (v)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
2134     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
2135 
2136     \textcolor{comment}{// Rectified Camera System}
2137     point.x=point.x/w;
2138     point.y=point.y/w;
2139     point.z=point.z/w;
2140 
2141     \textcolor{comment}{// We transform to H Coordinate System}
2142     Mat RLrectTmp=this->getRLrect().t(); \textcolor{comment}{// First it transform the point to the unrectified camera
       reference system}
2143     Mat Tfake = Mat::zeros(0,3,CV\_64F);
2144     Mat P(4,1,CV\_64FC1);
2145     P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2146     P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2147     P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2148     P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2149 
2150     Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2151     P=H*Hrect*P;
2152 
2153     point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2154     point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2155     point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2156 
2157     \textcolor{keywordflow}{return} point;
2158 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a3c8ef84424fa111c63437a3db8f04333}} 
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation@{triangulation}}
\index{triangulation@{triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{triangulation()}{triangulation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Point3f Stereo\+Camera\+::triangulation (\begin{DoxyParamCaption}\item[{Point2f \&}]{point1,  }\item[{Point2f \&}]{point2 }\end{DoxyParamCaption})}



It performs the triangulation using the stored in the internal P1 and P2 3x4 \hyperlink{classCamera}{Camera} Matrices. 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2D point coordinates in the first image. \\
\hline
{\em point2} & the 2D point coordinates in the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3D point wrt the first camera reference system. 
\end{DoxyReturn}


Definition at line 861 of file stereo\+Camera.\+cpp.



Referenced by chierality(), find\+Match(), and triangulation().


\begin{DoxyCode}
861                                                                            \{
862 
863     Point3f point3D;
864     Mat J=Mat(4,4,CV\_64FC1);
865     J.setTo(0);
866     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<4; j++) \{
867 
868         \textcolor{keywordtype}{int} rowA=0;
869         \textcolor{keywordtype}{int} rowB=2;
870 
871         J.at<\textcolor{keywordtype}{double}>(0,j)=(pointleft.x*this->Pleft.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pleft.at<\textcolor{keywordtype}{double}>(rowA,j));
872         J.at<\textcolor{keywordtype}{double}>(2,j)=(pointRight.x*this->Pright.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pright.at<\textcolor{keywordtype}{double}>(rowA,j))
      ;
873 
874         rowA=1;
875 
876         J.at<\textcolor{keywordtype}{double}>(1,j)=(pointleft.y*this->Pleft.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pleft.at<\textcolor{keywordtype}{double}>(rowA,j));
877         J.at<\textcolor{keywordtype}{double}>(3,j)=(pointRight.y*this->Pright.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pright.at<\textcolor{keywordtype}{double}>(rowA,j))
      ;
878     \}
879     SVD decom(J);
880     Mat V= decom.vt;
881 
882     point3D.x=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,0))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
883     point3D.y=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,1))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
884     point3D.z=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,2))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
885     \textcolor{keywordflow}{return} point3D;
886 
887 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_ab68c8d3bd07f542243d681fbe8c8c6b7}} 
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation@{triangulation}}
\index{triangulation@{triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{triangulation()}{triangulation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Point3f Stereo\+Camera\+::triangulation (\begin{DoxyParamCaption}\item[{Point2f \&}]{point1,  }\item[{Point2f \&}]{point2,  }\item[{Mat}]{Camera1,  }\item[{Mat}]{Camera2 }\end{DoxyParamCaption})}



It performs the triangulation (HZ Chap 12.\+2 homogenous solution). 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2D point coordinates in the first image. \\
\hline
{\em point2} & the 2D point coordinates in the second image. \\
\hline
{\em Camera1} & the 3x4 camera matrix of the first image. \\
\hline
{\em Camera2} & the 3x4 camera matrix of the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3D point wrt the first camera reference system. 
\end{DoxyReturn}


Definition at line 1370 of file stereo\+Camera.\+cpp.



References triangulation().


\begin{DoxyCode}
1370                                                                                                      \{
1371 
1372     Point3f point3D;
1373     Mat J=Mat(4,4,CV\_64FC1);
1374     J.setTo(0);
1375 
1376     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<4; j++) \{
1377 
1378         \textcolor{keywordtype}{int} rowA=0;
1379         \textcolor{keywordtype}{int} rowB=2;
1380 
1381         J.at<\textcolor{keywordtype}{double}>(0,j)=(pointleft.x*Camera1.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera1.at<\textcolor{keywordtype}{double}>(rowA,j));
1382         J.at<\textcolor{keywordtype}{double}>(2,j)=(pointRight.x*Camera2.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera2.at<\textcolor{keywordtype}{double}>(rowA,j));
1383 
1384         rowA=1;
1385 
1386         J.at<\textcolor{keywordtype}{double}>(1,j)=(pointleft.y*Camera1.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera1.at<\textcolor{keywordtype}{double}>(rowA,j));
1387         J.at<\textcolor{keywordtype}{double}>(3,j)=(pointRight.y*Camera2.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera2.at<\textcolor{keywordtype}{double}>(rowA,j));
1388     \}
1389     SVD decom(J);
1390     Mat V= decom.vt;
1391 
1392     \textcolor{comment}{// printMatrix(V);}
1393 
1394     \textcolor{comment}{/*Mat sol=Mat(4,1,CV\_64FC1);}
1395 \textcolor{comment}{        sol.at<double>(0,0)=V.at<double>(0,0);}
1396 \textcolor{comment}{        sol.at<double>(1,0)=V.at<double>(1,1);}
1397 \textcolor{comment}{        sol.at<double>(2,0)=V.at<double>(2,2);}
1398 \textcolor{comment}{        sol.at<double>(3,0)=V.at<double>(3,3);}
1399 \textcolor{comment}{}
1400 \textcolor{comment}{        Mat test=J*sol;}
1401 \textcolor{comment}{}
1402 \textcolor{comment}{        printMatrix(test);*/}
1403     point3D.x=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,0))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1404     point3D.y=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,1))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1405     point3D.z=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,2))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1406     \textcolor{keywordflow}{return} point3D;
1407 
1408 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_aaef25d8723eefdbab6e27c348492126b}} 
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation\+LS@{triangulation\+LS}}
\index{triangulation\+LS@{triangulation\+LS}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{triangulation\+L\+S()}{triangulationLS()}}
{\footnotesize\ttfamily Point3f Stereo\+Camera\+::triangulation\+LS (\begin{DoxyParamCaption}\item[{Point2f \&}]{point1,  }\item[{Point2f \&}]{point2,  }\item[{Mat}]{Camera1,  }\item[{Mat}]{Camera2 }\end{DoxyParamCaption})}



It performs the least square triangulation (HZ Chap 12.\+2 Inhomogenous solution). 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2D point coordinates in the first image. \\
\hline
{\em point2} & the 2D point coordinates in the second image. \\
\hline
{\em Camera1} & the 3x4 camera matrix of the first image. \\
\hline
{\em Camera2} & the 3x4 camera matrix of the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3D point wrt the first camera reference system. 
\end{DoxyReturn}
\mbox{\label{classStereoCamera_a2751f357e5fabc7099303d45425208d7}} 
\index{Stereo\+Camera@{Stereo\+Camera}!undistort\+Images@{undistort\+Images}}
\index{undistort\+Images@{undistort\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{undistort\+Images()}{undistortImages()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::undistort\+Images (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



It undistorts the images. 

\begin{DoxyNote}{Note}
Set undistortion coefficients before using this method. 
\end{DoxyNote}


Definition at line 1475 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1475                                    \{
1476     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
1477         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
1478         \textcolor{keywordflow}{return};
1479     \}
1480     \textcolor{keywordflow}{if}(this->imleft.empty() || this->imright.empty()) \{
1481         cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
1482         \textcolor{keywordflow}{return};
1483     \}
1484 
1485     undistort(this->imleft,this->imleftund,this->Kleft,this->DistL);
1486     undistort(this->imright,this->imrightund,this->Kright,this->DistR);
1487 \}
\end{DoxyCode}
\mbox{\label{classStereoCamera_a5b15c07def1c09f53bfc6141f303fa09}} 
\index{Stereo\+Camera@{Stereo\+Camera}!update\+Mappings@{update\+Mappings}}
\index{update\+Mappings@{update\+Mappings}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection{\texorpdfstring{update\+Mappings()}{updateMappings()}}
{\footnotesize\ttfamily void Stereo\+Camera\+::update\+Mappings (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+XX. 

\begin{DoxyReturn}{Returns}
X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+X\+XX 
\end{DoxyReturn}


Definition at line 2437 of file stereo\+Camera.\+cpp.



References get\+Im\+Left().


\begin{DoxyCode}
2438 \{
2439 
2440     \textcolor{keywordtype}{int} rows = this->getImLeft().rows;
2441     \textcolor{keywordtype}{int} cols = this->getImLeft().cols;
2442 
2443     \textcolor{keywordflow}{if} (cameraChanged)
2444     \{
2445 
2446         std::lock\_guard<std::mutex> lock(mtx);
2447 
2448         Mat inverseMapL(rows*cols,1,CV\_32FC2);
2449         Mat inverseMapR(rows*cols,1,CV\_32FC2);
2450 
2451         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y=0; y<rows; y++)
2452         \{
2453             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x=0; x<cols; x++)
2454             \{
2455                 inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*cols+x)[0]=(\textcolor{keywordtype}{float})x;
2456                 inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*cols+x)[1]=(\textcolor{keywordtype}{float})y;
2457                 inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*cols+x)[0]=(\textcolor{keywordtype}{float})x;
2458                 inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*cols+x)[1]=(\textcolor{keywordtype}{float})y;
2459             \}
2460         \}
2461 
2462         undistortPoints(inverseMapL,inverseMapL,this->Kleft,this->DistL,this->RLrect,this->PLrect);
2463         undistortPoints(inverseMapR,inverseMapR,this->Kright,this->DistR,this->RRrect,this->PRrect);
2464 
2465         Mat mapperL=inverseMapL.reshape(2,rows);
2466         Mat mapperR=inverseMapR.reshape(2,rows);
2467         this->MapperL=mapperL;
2468         this->MapperR=mapperR;
2469 
2470     \}
2471 
2472 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/runner/work/stereo-\/vision/stereo-\/vision/gh-\/pages/lib/include/i\+Cub/stereo\+Vision/stereo\+Camera.\+h\item 
/home/runner/work/stereo-\/vision/stereo-\/vision/gh-\/pages/lib/src/stereo\+Camera.\+cpp\end{DoxyCompactItemize}
